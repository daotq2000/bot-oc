Subject: [PATCH] done tp
---
Index: logic_đúng_khi_update_position_realtime_update_update_symbol_filters.patch
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/logic_đúng_khi_update_position_realtime_update_update_symbol_filters.patch b/logic_đúng_khi_update_position_realtime_update_update_symbol_filters.patch
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/logic_đúng_khi_update_position_realtime_update_update_symbol_filters.patch	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,1740 @@
+Subject: [PATCH] logic đúng khi update position realtime
+update
+update symbol filters
+---
+Index: src/models/SymbolFilter.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/models/SymbolFilter.js b/src/models/SymbolFilter.js
+--- a/src/models/SymbolFilter.js	(revision 02387811a4120a110c9ace1ecb73b3331410a1df)
++++ b/src/models/SymbolFilter.js	(revision d600c2a18c5134c14afb572cb6d0572cee4c5337)
+@@ -50,4 +50,45 @@
+ 
+     await pool.execute(sql, values);
+   }
++
++  /**
++   * Delete symbol filters for a given exchange that are NOT in the provided symbol list.
++   * Used to remove delisted or unavailable symbols.
++   * @param {string} exchange - Exchange name (e.g., 'binance', 'mexc')
++   * @param {Array<string>} keepSymbols - Array of symbols to keep (uppercase, e.g., ['BTCUSDT', 'ETHUSDT'])
++   * @returns {Promise<number>} Number of rows deleted
++   */
++  static async deleteByExchangeAndSymbols(exchange, keepSymbols) {
++    if (!exchange || !Array.isArray(keepSymbols) || keepSymbols.length === 0) {
++      // If keepSymbols is empty, don't delete anything (fail-safe)
++      return 0;
++    }
++
++    const normalizedSymbols = keepSymbols.map(s => s.toUpperCase()).filter(s => s);
++    if (normalizedSymbols.length === 0) {
++      return 0;
++    }
++
++    const placeholders = normalizedSymbols.map(() => '?').join(',');
++    const sql = `
++      DELETE FROM symbol_filters
++      WHERE exchange = ? AND symbol NOT IN (${placeholders})
++    `;
++
++    const [result] = await pool.execute(sql, [exchange, ...normalizedSymbols]);
++    return result.affectedRows || 0;
++  }
++
++  /**
++   * Get all symbols for a specific exchange from the database.
++   * @param {string} exchange - Exchange name (e.g., 'binance', 'mexc')
++   * @returns {Promise<Array<string>>} Array of normalized symbols (uppercase)
++   */
++  static async getSymbolsByExchange(exchange) {
++    const [rows] = await pool.execute(
++      'SELECT symbol FROM symbol_filters WHERE exchange = ?',
++      [exchange]
++    );
++    return rows.map(r => (r.symbol || '').toUpperCase()).filter(s => s);
++  }
+ }
+Index: src/services/ExchangeInfoService.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/services/ExchangeInfoService.js b/src/services/ExchangeInfoService.js
+--- a/src/services/ExchangeInfoService.js	(revision 02387811a4120a110c9ace1ecb73b3331410a1df)
++++ b/src/services/ExchangeInfoService.js	(revision d600c2a18c5134c14afb572cb6d0572cee4c5337)
+@@ -10,9 +10,14 @@
+  * Exchange Info Service - Manages fetching and caching of symbol filters
+  */
+ class ExchangeInfoService {
+-  constructor() {
++  constructor({ symbolFilterDAO = SymbolFilter, binanceClientFactory = (apiKey, secretKey, isTestnet = false, exInfoSvc = null) => new BinanceDirectClient(apiKey, secretKey, isTestnet, exInfoSvc), mexcFactory = () => new ccxt.mexc({ enableRateLimit: true, options: { defaultType: 'swap' } }), loggerInst = logger, config = configService } = {}) {
+     this.filtersCache = new Map(); // symbol -> { tickSize, stepSize, minNotional, maxLeverage }
+     this.isInitialized = false;
++    this.symbolFilterDAO = symbolFilterDAO;
++    this.binanceClientFactory = binanceClientFactory;
++    this.mexcFactory = mexcFactory;
++    this.logger = loggerInst;
++    this.config = config;
+   }
+ 
+   /**
+@@ -23,7 +28,7 @@
+    */
+   async getSymbolsFromDB(exchange, onlyUSDT = true, limit = null) {
+     try {
+-      const rows = await SymbolFilter.findAll();
++      const rows = await this.symbolFilterDAO.findAll();
+       const ex = String(exchange || '').toLowerCase();
+       let syms = rows
+         .filter(r => (r.exchange || '').toLowerCase() === ex)
+@@ -35,7 +40,7 @@
+       if (Number.isFinite(limit) && limit > 0) return uniq.slice(0, limit);
+       return uniq;
+     } catch (e) {
+-      logger.warn(`[ExchangeInfoService] getSymbolsFromDB failed for ${exchange}: ${e?.message || e}`);
++      this.logger.warn(`[ExchangeInfoService] getSymbolsFromDB failed for ${exchange}: ${e?.message || e}`);
+       return [];
+     }
+   }
+@@ -61,19 +66,23 @@
+    * This should be called on bot startup.
+    */
+   async updateFiltersFromExchange() {
+-    logger.info('Updating symbol filters from Binance...');
++    this.logger.info('Updating symbol filters from Binance...');
+     try {
+-      const binanceClient = new BinanceDirectClient('', '', false); // No keys needed for public data
++      const binanceClient = this.binanceClientFactory('', '', false, this); // No keys needed for public data
+       const exchangeInfo = await binanceClient.getExchangeInfo();
+ 
+       if (!exchangeInfo || !exchangeInfo.symbols) {
+-        logger.error('Failed to fetch exchange info from Binance.');
++        this.this.logger.error('Failed to fetch exchange info from Binance.');
+         return;
+       }
+ 
+       const filtersToSave = [];
+       for (const symbolInfo of exchangeInfo.symbols) {
+         if (symbolInfo.status !== 'TRADING') continue;
++        // Futures-only USDT-margined perpetual contracts
++        const quote = (symbolInfo.quoteAsset || '').toUpperCase();
++        const contractType = (symbolInfo.contractType || '').toUpperCase();
++        if (quote !== 'USDT' || (contractType && contractType !== 'PERPETUAL')) continue;
+ 
+         const priceFilter = symbolInfo.filters.find(f => f.filterType === 'PRICE_FILTER');
+         const lotSizeFilter = symbolInfo.filters.find(f => f.filterType === 'LOT_SIZE');
+@@ -102,16 +111,26 @@
+         }
+       }
+ 
++      // Get current symbols from DB for this exchange
++      const currentDbSymbols = await this.symbolFilterDAO.getSymbolsByExchange('binance');
++      const exchangeSymbols = filtersToSave.map(f => f.symbol.toUpperCase());
++
++      // Delete symbols that are no longer available on exchange
++      const deletedCount = await this.symbolFilterDAO.deleteByExchangeAndSymbols('binance', exchangeSymbols);
++      if (deletedCount > 0) {
++        this.logger.info(`Deleted ${deletedCount} delisted/unavailable Binance symbols from database.`);
++      }
++
+       // Bulk insert/update into the database
+-      await SymbolFilter.bulkUpsert(filtersToSave);
+-      logger.info(`Successfully updated ${filtersToSave.length} Binance symbol filters in the database.`);
++      await this.symbolFilterDAO.bulkUpsert(filtersToSave);
++      this.logger.info(`Successfully updated ${filtersToSave.length} Binance symbol filters in the database.`);
+ 
+       // Clear and reload the in-memory cache
+       this.filtersCache.clear();
+       await this.loadFiltersFromDB();
+ 
+     } catch (error) {
+-      logger.error('Error updating symbol filters (Binance):', error);
++      this.this.logger.error('Error updating symbol filters (Binance):', error);
+     }
+   }
+ 
+@@ -119,9 +138,9 @@
+    * Fetch all MEXC USDT-M swap markets and update symbol_filters.
+    */
+   async updateMexcFiltersFromExchange() {
+-    logger.info('Updating symbol filters from MEXC...');
++    this.logger.info('Updating symbol filters from MEXC...');
+     try {
+-      const mexc = new ccxt.mexc({ enableRateLimit: true, options: { defaultType: 'swap' } });
++      const mexc = this.mexcFactory();
+       // Force .co domain base and add fetch failsafe
+       try {
+         const co = 'https://api.mexc.co';
+@@ -215,30 +234,40 @@
+       }
+ 
+       if (filtersToSave.length === 0) {
+-        const futuresOnly = configService.getBoolean('MEXC_FUTURES_ONLY', true);
++        const futuresOnly = this.config.getBoolean('MEXC_FUTURES_ONLY', true)
+         if (futuresOnly) {
+-          logger.warn('No MEXC swap markets via CCXT. Futures-only mode: skipping spot fallback.');
++          this.logger.warn('No MEXC swap markets via CCXT. Futures-only mode: skipping spot fallback.');
+           return;
+         }
+-        logger.warn('No MEXC swap markets via CCXT. Falling back to /api/v3/exchangeInfo');
++        this.logger.warn('No MEXC swap markets via CCXT. Falling back to /api/v3/exchangeInfo');
+         await this.updateMexcFiltersFromSpotExchangeInfo();
+         return;
+       }
+ 
+-      await SymbolFilter.bulkUpsert(filtersToSave);
+-      logger.info(`Successfully updated ${filtersToSave.length} MEXC symbol filters in the database.`);
++      // Get current symbols from DB for this exchange
++      const currentDbSymbols = await this.symbolFilterDAO.getSymbolsByExchange('mexc');
++      const exchangeSymbols = filtersToSave.map(f => f.symbol.toUpperCase());
++
++      // Delete symbols that are no longer available on exchange
++      const deletedCount = await this.symbolFilterDAO.deleteByExchangeAndSymbols('mexc', exchangeSymbols);
++      if (deletedCount > 0) {
++        this.logger.info(`Deleted ${deletedCount} delisted/unavailable MEXC symbols from database.`);
++      }
++
++      await this.symbolFilterDAO.bulkUpsert(filtersToSave);
++      this.logger.info(`Successfully updated ${filtersToSave.length} MEXC symbol filters in the database.`);
+ 
+       // Refresh cache
+       this.filtersCache.clear();
+       await this.loadFiltersFromDB();
+     } catch (e) {
+-      logger.error('Error updating symbol filters (MEXC) via CCXT:', e);
+-      const futuresOnly = configService.getBoolean('MEXC_FUTURES_ONLY', true);
++      this.this.logger.error('Error updating symbol filters (MEXC) via CCXT:', e);
++      const futuresOnly = this.config.getBoolean('MEXC_FUTURES_ONLY', true)
+       if (futuresOnly) {
+-        logger.warn('Futures-only mode enabled: skipping MEXC spot exchangeInfo fallback.');
++        this.logger.warn('Futures-only mode enabled: skipping MEXC spot exchangeInfo fallback.');
+         return;
+       }
+-      logger.info('Falling back to MEXC spot exchangeInfo (REST) ...');
++      this.logger.info('Falling back to MEXC spot exchangeInfo (REST) ...');
+       await this.updateMexcFiltersFromSpotExchangeInfo();
+     }
+   }
+@@ -282,18 +311,28 @@
+       }
+ 
+       if (filtersToSave.length === 0) {
+-        logger.warn('MEXC REST fallback returned no symbols. Skipping update.');
++        this.logger.warn('MEXC REST fallback returned no symbols. Skipping update.');
+         return;
+       }
+ 
+-      await SymbolFilter.bulkUpsert(filtersToSave);
+-      logger.info(`Successfully updated ${filtersToSave.length} MEXC symbol filters from REST spot exchangeInfo.`);
++      // Get current symbols from DB for this exchange
++      const currentDbSymbols = await this.symbolFilterDAO.getSymbolsByExchange('mexc');
++      const exchangeSymbols = filtersToSave.map(f => f.symbol.toUpperCase());
++
++      // Delete symbols that are no longer available on exchange
++      const deletedCount = await this.symbolFilterDAO.deleteByExchangeAndSymbols('mexc', exchangeSymbols);
++      if (deletedCount > 0) {
++        this.logger.info(`Deleted ${deletedCount} delisted/unavailable MEXC symbols from database (REST fallback).`);
++      }
++
++      await this.symbolFilterDAO.bulkUpsert(filtersToSave);
++      this.logger.info(`Successfully updated ${filtersToSave.length} MEXC symbol filters from REST spot exchangeInfo.`);
+ 
+       // Refresh cache
+       this.filtersCache.clear();
+       await this.loadFiltersFromDB();
+     } catch (err) {
+-      logger.error('MEXC REST fallback failed:', err?.message || err);
++      this.this.logger.error('MEXC REST fallback failed:', err?.message || err);
+     }
+   }
+ 
+@@ -303,7 +342,7 @@
+    */
+   async getTradableSymbolsFromBinance() {
+     try {
+-      const client = new BinanceDirectClient('', '', false);
++      const client = this.binanceClientFactory('', '', false, this);
+       const info = await client.getExchangeInfo();
+       const set = new Set();
+       if (info?.symbols?.length) {
+@@ -319,7 +358,7 @@
+       }
+       return set;
+     } catch (e) {
+-      logger.error('getTradableSymbolsFromBinance failed:', e?.message || e);
++      this.this.logger.error('getTradableSymbolsFromBinance failed:', e?.message || e);
+       return new Set();
+     }
+   }
+@@ -330,7 +369,7 @@
+    */
+   async getTradableSymbolsFromMexc() {
+     try {
+-      const mexc = new ccxt.mexc({ enableRateLimit: true, options: { defaultType: 'swap' } });
++      const mexc = this.mexcFactory();
+       await mexc.loadMarkets();
+       const set = new Set();
+       for (const id in mexc.markets) {
+@@ -345,7 +384,7 @@
+       }
+       return set;
+     } catch (e) {
+-      logger.error('getTradableSymbolsFromMexc failed:', e?.message || e);
++      this.this.logger.error('getTradableSymbolsFromMexc failed:', e?.message || e);
+       return new Set();
+     }
+   }
+@@ -367,9 +406,9 @@
+    * Load all symbol filters from the database into the in-memory cache.
+    */
+   async loadFiltersFromDB() {
+-    logger.info('Loading symbol filters from database into cache...');
++    this.logger.info('Loading symbol filters from database into cache...');
+     try {
+-      const filters = await SymbolFilter.findAll();
++      const filters = await this.symbolFilterDAO.findAll();
+       // Prefer Binance filters when duplicate symbols exist.
+       // Load Binance first; for other exchanges, only set if not present.
+       const sorted = filters.sort((a, b) => {
+@@ -392,9 +431,9 @@
+         });
+       }
+       this.isInitialized = true;
+-      logger.info(`Loaded ${this.filtersCache.size} symbol filters into cache.`);
++      this.logger.info(`Loaded ${this.filtersCache.size} symbol filters into cache.`);
+     } catch (error) {
+-      logger.error('Error loading symbol filters from DB:', error);
++      this.this.logger.error('Error loading symbol filters from DB:', error);
+     }
+   }
+ 
+@@ -405,7 +444,7 @@
+    */
+   getFilters(symbol) {
+     if (!this.isInitialized) {
+-      logger.warn('ExchangeInfoService not initialized. Filters may be stale.');
++      this.logger.warn('ExchangeInfoService not initialized. Filters may be stale.');
+     }
+     return this.filtersCache.get(symbol.toUpperCase());
+   }
+@@ -451,6 +490,7 @@
+   }
+ }
+ 
+-// Export a singleton instance
++// Export class for testing and singleton instance for production
++export { ExchangeInfoService };
+ export const exchangeInfoService = new ExchangeInfoService();
+ 
+Index: tests/unit/services/ExchangeInfoService.test.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/tests/unit/services/ExchangeInfoService.test.js b/tests/unit/services/ExchangeInfoService.test.js
+new file mode 100644
+--- /dev/null	(revision d600c2a18c5134c14afb572cb6d0572cee4c5337)
++++ b/tests/unit/services/ExchangeInfoService.test.js	(revision d600c2a18c5134c14afb572cb6d0572cee4c5337)
+@@ -0,0 +1,268 @@
++import { describe, it, expect, beforeEach, jest } from '@jest/globals';
++import { ExchangeInfoService } from '../../../src/services/ExchangeInfoService.js';
++
++describe('ExchangeInfoService - Symbol Sync (unit)', () => {
++  let svc;
++  let mockDAO;
++  let mockLogger;
++  let mockConfig;
++  let mockBinanceClient;
++  let mockMexc;
++
++  beforeEach(() => {
++    mockDAO = {
++      findAll: jest.fn(),
++      bulkUpsert: jest.fn().mockResolvedValue(undefined),
++      deleteByExchangeAndSymbols: jest.fn().mockResolvedValue(0),
++      getSymbolsByExchange: jest.fn().mockResolvedValue([]),
++    };
++    mockLogger = { info: jest.fn(), warn: jest.fn(), error: jest.fn(), debug: jest.fn() };
++    mockConfig = { getBoolean: jest.fn().mockReturnValue(true) };
++    mockBinanceClient = { getExchangeInfo: jest.fn() };
++    mockMexc = {
++      markets: {},
++      fetchMarkets: jest.fn().mockResolvedValue(undefined),
++      loadMarkets: jest.fn().mockResolvedValue(undefined),
++      urls: {},
++      hostname: 'mexc.co',
++      fetch: jest.fn(),
++    };
++    svc = new ExchangeInfoService({
++      symbolFilterDAO: mockDAO,
++      binanceClientFactory: () => mockBinanceClient,
++      mexcFactory: () => mockMexc,
++      loggerInst: mockLogger,
++      config: mockConfig,
++    });
++  });
++
++  describe('Binance: updateFiltersFromExchange', () => {
++    it('inserts new symbols from exchange', async () => {
++      mockBinanceClient.getExchangeInfo.mockResolvedValue({
++        symbols: [
++          {
++            symbol: 'BTCUSDT',
++            status: 'TRADING',
++            filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++            leverageBrackets: [{ initialLeverage: 125 }],
++          },
++          {
++            symbol: 'ETHUSDT',
++            status: 'TRADING',
++            filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++            leverageBrackets: [{ initialLeverage: 100 }],
++          },
++        ],
++      });
++
++      const clearSpy = jest.spyOn(svc.filtersCache, 'clear');
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateFiltersFromExchange();
++
++      expect(mockDAO.getSymbolsByExchange).toHaveBeenCalledWith('binance');
++      expect(mockDAO.deleteByExchangeAndSymbols).toHaveBeenCalledWith('binance', ['BTCUSDT', 'ETHUSDT']);
++      expect(mockDAO.bulkUpsert).toHaveBeenCalledWith([
++        {
++          exchange: 'binance',
++          symbol: 'BTCUSDT',
++          tick_size: '0.01',
++          step_size: '0.001',
++          min_notional: '5',
++          max_leverage: 125,
++        },
++        {
++          exchange: 'binance',
++          symbol: 'ETHUSDT',
++          tick_size: '0.01',
++          step_size: '0.001',
++          min_notional: '5',
++          max_leverage: 100,
++        },
++      ]);
++      expect(clearSpy).toHaveBeenCalledTimes(1);
++      expect(svc.loadFiltersFromDB).toHaveBeenCalledTimes(1);
++    });
++
++    it('deletes symbols not returned by exchange (delisted/unavailable) and clears cache', async () => {
++      mockBinanceClient.getExchangeInfo.mockResolvedValue({
++        symbols: [
++          {
++            symbol: 'BTCUSDT',
++            status: 'TRADING',
++            filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++          },
++        ],
++      });
++      mockDAO.getSymbolsByExchange.mockResolvedValue(['BTCUSDT', 'SOLUSDT', 'ABCUSDT']);
++      mockDAO.deleteByExchangeAndSymbols.mockResolvedValue(2);
++
++      const clearSpy = jest.spyOn(svc.filtersCache, 'clear');
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateFiltersFromExchange();
++
++      expect(mockDAO.deleteByExchangeAndSymbols).toHaveBeenCalledWith('binance', ['BTCUSDT']);
++      expect(mockLogger.info).toHaveBeenCalledWith(expect.stringContaining('Deleted 2 delisted/unavailable Binance symbols'));
++      expect(clearSpy).toHaveBeenCalledTimes(1);
++      expect(svc.loadFiltersFromDB).toHaveBeenCalledTimes(1);
++    });
++
++    it('keeps existing symbols that are still available (no deletions) and clears cache', async () => {
++      mockBinanceClient.getExchangeInfo.mockResolvedValue({
++        symbols: [
++          {
++            symbol: 'BTCUSDT', status: 'TRADING', filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++          },
++          {
++            symbol: 'ETHUSDT', status: 'TRADING', filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++          },
++        ],
++      });
++      mockDAO.getSymbolsByExchange.mockResolvedValue(['BTCUSDT', 'ETHUSDT']);
++      mockDAO.deleteByExchangeAndSymbols.mockResolvedValue(0);
++      const clearSpy = jest.spyOn(svc.filtersCache, 'clear');
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateFiltersFromExchange();
++
++      expect(mockDAO.deleteByExchangeAndSymbols).toHaveBeenCalledWith('binance', ['BTCUSDT', 'ETHUSDT']);
++      expect(mockDAO.bulkUpsert).toHaveBeenCalled();
++      expect(clearSpy).toHaveBeenCalledTimes(1);
++      expect(svc.loadFiltersFromDB).toHaveBeenCalledTimes(1);
++    });
++
++    it('does not insert spot-only symbols when not present in Futures list', async () => {
++      // Imagine SPOTONLYUSDT exists on Spot, but Futures API does not return it.
++      mockBinanceClient.getExchangeInfo.mockResolvedValue({
++        symbols: [
++          {
++            symbol: 'BTCUSDT',
++            status: 'TRADING',
++            filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++          },
++        ],
++      });
++      const clearSpy = jest.spyOn(svc.filtersCache, 'clear');
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateFiltersFromExchange();
++
++      // Ensure upsert only contains Futures symbols (BTCUSDT), not SPOTONLYUSDT
++      const upsertArg = mockDAO.bulkUpsert.mock.calls[0][0];
++      expect(upsertArg.map(x => x.symbol)).toEqual(['BTCUSDT']);
++      expect(clearSpy).toHaveBeenCalledTimes(1);
++      expect(svc.loadFiltersFromDB).toHaveBeenCalledTimes(1);
++    });
++
++    it('fail-safe when exchange returns empty symbols: no mass deletion and cache cleared', async () => {
++      mockBinanceClient.getExchangeInfo.mockResolvedValue({ symbols: [] });
++      const clearSpy = jest.spyOn(svc.filtersCache, 'clear');
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateFiltersFromExchange();
++
++      expect(mockDAO.deleteByExchangeAndSymbols).toHaveBeenCalledWith('binance', []);
++      expect(mockDAO.bulkUpsert).toHaveBeenCalledWith([]);
++      expect(clearSpy).toHaveBeenCalledTimes(1);
++      expect(svc.loadFiltersFromDB).toHaveBeenCalledTimes(1);
++    });
++
++    it('skips non-TRADING and missing-filter symbols', async () => {
++      mockBinanceClient.getExchangeInfo.mockResolvedValue({
++        symbols: [
++          {
++            symbol: 'BTCUSDT', status: 'TRADING', filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++          },
++          {
++            symbol: 'DELISTEDUSDT', status: 'BREAK', filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++              { filterType: 'LOT_SIZE', stepSize: '0.001' },
++              { filterType: 'MIN_NOTIONAL', notional: '5' },
++            ],
++          },
++          {
++            symbol: 'INVALIDUSDT', status: 'TRADING', filters: [
++              { filterType: 'PRICE_FILTER', tickSize: '0.01' },
++            ],
++          },
++        ],
++      });
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateFiltersFromExchange();
++
++      expect(mockDAO.bulkUpsert).toHaveBeenCalledWith([
++        {
++          exchange: 'binance', symbol: 'BTCUSDT', tick_size: '0.01', step_size: '0.001', min_notional: '5', max_leverage: 125,
++        },
++      ]);
++    });
++
++    it('logs error and does not upsert when fetch throws', async () => {
++      const err = new Error('Network');
++      mockBinanceClient.getExchangeInfo.mockRejectedValue(err);
++
++      await svc.updateFiltersFromExchange();
++
++      expect(mockLogger.error).toHaveBeenCalledWith('Error updating symbol filters (Binance):', err);
++      expect(mockDAO.bulkUpsert).not.toHaveBeenCalled();
++    });
++  });
++
++  describe('MEXC: updateMexcFiltersFromExchange', () => {
++    it('inserts new and deletes delisted for MEXC', async () => {
++      mockMexc.markets = {
++        'BTC/USDT:USDT': {
++          base: 'BTC', quote: 'USDT', type: 'swap', contract: true, active: true,
++          precision: { price: 2, amount: 3 },
++          limits: { cost: { min: 5 }, leverage: { max: 125 } },
++          info: {},
++        },
++      };
++
++      mockDAO.getSymbolsByExchange.mockResolvedValue(['ETHUSDT']);
++      mockDAO.deleteByExchangeAndSymbols.mockResolvedValue(1);
++      svc.loadFiltersFromDB = jest.fn().mockResolvedValue(undefined);
++
++      await svc.updateMexcFiltersFromExchange();
++
++      expect(mockDAO.getSymbolsByExchange).toHaveBeenCalledWith('mexc');
++      expect(mockDAO.deleteByExchangeAndSymbols).toHaveBeenCalledWith('mexc', ['BTCUSDT']);
++      expect(mockDAO.bulkUpsert).toHaveBeenCalledWith([
++        {
++          exchange: 'mexc', symbol: 'BTCUSDT', tick_size: '0.01', step_size: '0.001', min_notional: 5, max_leverage: 125,
++        },
++      ]);
++      expect(svc.loadFiltersFromDB).toHaveBeenCalled();
++    });
++  });
++});
+Index: src/app.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/app.js b/src/app.js
+--- a/src/app.js	(revision d600c2a18c5134c14afb572cb6d0572cee4c5337)
++++ b/src/app.js	(revision a94457e791ca16cddb81a17fed7442a4c5ee801d)
+@@ -78,6 +78,7 @@
+       await AppConfig.set('SIGNAL_SCAN_INTERVAL_MS', '5000', 'Signal scanner job interval in milliseconds');
+       await AppConfig.set('NON_BINANCE_TICKER_CACHE_MS', '1500', 'Cache lifetime for non-Binance ticker REST calls (ms)');
+       await AppConfig.set('PRICE_ALERT_SCAN_INTERVAL_MS', '500', 'Price alert scanner job interval in milliseconds');
++      await AppConfig.set('PRICE_ALERT_MODULE_ENABLED', 'true', 'Enable/Disable the entire Price Alert module (workers, scanners, alerts)');
+       await AppConfig.set('PRICE_ALERT_CHECK_ENABLED', 'true', 'Enable price alert checking for MEXC and other exchanges');
+       await AppConfig.set('PRICE_ALERT_SYMBOL_REFRESH_INTERVAL_MS', '30000', 'Interval to refresh Price Alert symbols from config/DB (ms)');
+       await AppConfig.set('PRICE_ALERT_WS_SUBSCRIBE_INTERVAL_MS', '60000', 'Interval to update WebSocket subscriptions for Price Alert (ms)');
+@@ -212,30 +213,35 @@
+     // ============================================
+     // PRICE ALERT WORKER (Always-on, Independent)
+     // ============================================
++    const alertModuleEnabled = configService.getBoolean('PRICE_ALERT_MODULE_ENABLED', true);
+     logger.info('='.repeat(60));
+-    logger.info('Initializing Price Alert Worker (Always-on, Independent)...');
++    logger.info(`Initializing Price Alert Worker (Always-on, Independent) - Enabled=${alertModuleEnabled}`);
+     logger.info('='.repeat(60));
+ 
+-    // Pre-load PriceAlertConfig cache on startup (TTL: 30 minutes)
+-    try {
+-      logger.info('[App] Pre-loading PriceAlertConfig cache...');
+-      const { PriceAlertConfig } = await import('./models/PriceAlertConfig.js');
+-      await PriceAlertConfig.findAll(); // This will cache all configs
+-      logger.info('[App] ✅ PriceAlertConfig cache pre-loaded (TTL: 30 minutes)');
+-    } catch (error) {
+-      logger.warn('[App] Failed to pre-load PriceAlertConfig cache:', error?.message || error);
+-    }
+-    
+-    try {
+-      const { PriceAlertWorker } = await import('./workers/PriceAlertWorker.js');
+-      priceAlertWorker = new PriceAlertWorker();
+-      await priceAlertWorker.initialize(telegramService);
+-      priceAlertWorker.start();
+-      logger.info('✅ Price Alert Worker started successfully');
+-    } catch (error) {
+-      logger.error('❌ CRITICAL: Failed to start Price Alert Worker:', error?.message || error);
+-      logger.error('Price Alert system is critical - application will continue but alerts may not work');
+-      // Don't exit - Price Alert should be resilient
++    if (alertModuleEnabled) {
++      // Pre-load PriceAlertConfig cache on startup (TTL: 30 minutes)
++      try {
++        logger.info('[App] Pre-loading PriceAlertConfig cache...');
++        const { PriceAlertConfig } = await import('./models/PriceAlertConfig.js');
++        await PriceAlertConfig.findAll(); // This will cache all configs
++        logger.info('[App] ✅ PriceAlertConfig cache pre-loaded (TTL: 30 minutes)');
++      } catch (error) {
++        logger.warn('[App] Failed to pre-load PriceAlertConfig cache:', error?.message || error);
++      }
++      
++      try {
++        const { PriceAlertWorker } = await import('./workers/PriceAlertWorker.js');
++        priceAlertWorker = new PriceAlertWorker();
++        await priceAlertWorker.initialize(telegramService);
++        priceAlertWorker.start();
++        logger.info('✅ Price Alert Worker started successfully');
++      } catch (error) {
++        logger.error('❌ CRITICAL: Failed to start Price Alert Worker:', error?.message || error);
++        logger.error('Price Alert system is critical - application will continue but alerts may not work');
++        // Don't exit - Price Alert should be resilient
++      }
++    } else {
++      logger.warn('[App] PRICE_ALERT_MODULE_ENABLED=false → Price Alert Worker not started');
+     }
+ 
+     // ============================================
+Index: migrations/20251219100000-create-entry-orders-table.cjs
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/migrations/20251219100000-create-entry-orders-table.cjs b/migrations/20251219100000-create-entry-orders-table.cjs
+new file mode 100644
+--- /dev/null	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
++++ b/migrations/20251219100000-create-entry-orders-table.cjs	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -0,0 +1,72 @@
++'use strict';
++
++module.exports = {
++  up: async (queryInterface, Sequelize) => {
++    await queryInterface.createTable('entry_orders', {
++      id: {
++        allowNull: false,
++        autoIncrement: true,
++        primaryKey: true,
++        type: Sequelize.INTEGER
++      },
++      strategy_id: {
++        type: Sequelize.INTEGER,
++        allowNull: false,
++        references: { model: 'strategies', key: 'id' },
++        onUpdate: 'CASCADE',
++        onDelete: 'CASCADE'
++      },
++      bot_id: {
++        type: Sequelize.INTEGER,
++        allowNull: false,
++        references: { model: 'bots', key: 'id' },
++        onUpdate: 'CASCADE',
++        onDelete: 'CASCADE'
++      },
++      order_id: {
++        type: Sequelize.STRING,
++        allowNull: false,
++        unique: true
++      },
++      symbol: {
++        type: Sequelize.STRING,
++        allowNull: false
++      },
++      side: {
++        type: Sequelize.STRING(10),
++        allowNull: false
++      },
++      amount: {
++        type: Sequelize.DECIMAL(20, 8),
++        allowNull: false
++      },
++      entry_price: {
++        type: Sequelize.DECIMAL(20, 8),
++        allowNull: false
++      },
++      status: {
++        type: Sequelize.ENUM('open', 'filled', 'canceled', 'expired'),
++        allowNull: false,
++        defaultValue: 'open'
++      },
++      created_at: {
++        allowNull: false,
++        type: Sequelize.DATE,
++        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
++      },
++      updated_at: {
++        allowNull: false,
++        type: Sequelize.DATE,
++        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP')
++      }
++    });
++
++    await queryInterface.addIndex('entry_orders', ['status']);
++    await queryInterface.addIndex('entry_orders', ['strategy_id']);
++    await queryInterface.addIndex('entry_orders', ['bot_id', 'status']);
++  },
++
++  down: async (queryInterface, Sequelize) => {
++    await queryInterface.dropTable('entry_orders');
++  }
++};
+Index: scripts/ensure_entry_orders_schema.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/scripts/ensure_entry_orders_schema.js b/scripts/ensure_entry_orders_schema.js
+new file mode 100644
+--- /dev/null	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
++++ b/scripts/ensure_entry_orders_schema.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -0,0 +1,40 @@
++import pool from '../src/config/database.js';
++
++async function ensureEntryOrdersTable() {
++  await pool.execute(`
++    CREATE TABLE IF NOT EXISTS entry_orders (
++      id INT PRIMARY KEY AUTO_INCREMENT,
++      strategy_id INT NOT NULL,
++      bot_id INT NOT NULL,
++      order_id VARCHAR(100) NOT NULL,
++      symbol VARCHAR(50) NOT NULL,
++      side VARCHAR(10) NOT NULL,
++      amount DECIMAL(20,8) NOT NULL,
++      entry_price DECIMAL(20,8) NOT NULL,
++      status ENUM('open','filled','canceled','expired') NOT NULL DEFAULT 'open',
++      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
++      updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
++      UNIQUE KEY uniq_order (order_id),
++      INDEX idx_status (status),
++      INDEX idx_strategy (strategy_id),
++      INDEX idx_bot_status (bot_id, status),
++      CONSTRAINT fk_entry_orders_strategy FOREIGN KEY (strategy_id) REFERENCES strategies(id) ON DELETE CASCADE,
++      CONSTRAINT fk_entry_orders_bot FOREIGN KEY (bot_id) REFERENCES bots(id) ON DELETE CASCADE
++    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
++  `);
++  console.log('Ensured table entry_orders exists.');
++}
++
++(async () => {
++  try {
++    await ensureEntryOrdersTable();
++  } catch (e) {
++    console.error('Schema ensure error (entry_orders):', e?.message || e);
++    process.exit(1);
++  } finally {
++    try { await pool.end(); } catch (_) {}
++  }
++  process.exit(0);
++})();
++
++
+Index: scripts/test_entry_orders_flow_binance.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/scripts/test_entry_orders_flow_binance.js b/scripts/test_entry_orders_flow_binance.js
+new file mode 100644
+--- /dev/null	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
++++ b/scripts/test_entry_orders_flow_binance.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -0,0 +1,256 @@
++#!/usr/bin/env node
++/**
++ * Test script: verify entry_orders + monitor flow on Binance Futures testnet (bot_id=3)
++ *
++ * Flow:
++ *  - Create a temporary strategy in DB for bot 3
++ *  - Place a SMALL LIMIT entry order using the real strategy_id
++ *  - Immediately inspect:
++ *      - entry_orders: new row should appear with status='open'
++ *      - positions: should NOT have new open position yet (if order not filled)
++ *  - Then:
++ *      - Wait some seconds and re-check; if order filled, EntryOrderMonitor should have:
++ *          - created a Position
++ *          - marked entry_orders.status='filled'
++ *      - If cancelled/expired, entry_orders.status should become 'canceled'/'expired' and still no Position
++ *  - Finally, clean up (delete) the temporary strategy
++ *
++ * Usage:
++ *  node scripts/test_entry_orders_flow_binance.js --symbol ETHUSDT --side long|short --amount 50 --offset_pct 0.5 --confirm
++ */
++
++import dotenv from 'dotenv';
++import logger from '../src/utils/logger.js';
++import pool from '../src/config/database.js';
++import { ExchangeService } from '../src/services/ExchangeService.js';
++import { OrderService } from '../src/services/OrderService.js';
++import { TelegramService } from '../src/services/TelegramService.js';
++
++dotenv.config();
++
++function parseArgs(argv) {
++  const out = {};
++  for (let i = 0; i < argv.length; i++) {
++    const a = argv[i];
++    if (a.startsWith('--')) {
++      const key = a.replace(/^--/, '');
++      const next = argv[i + 1];
++      if (!next || next.startsWith('--')) {
++        out[key] = true;
++      } else {
++        out[key] = next;
++        i++;
++      }
++    }
++  }
++  return out;
++}
++
++const args = parseArgs(process.argv.slice(2));
++
++function usage(msg = null) {
++  if (msg) console.error(`Error: ${msg}`);
++  console.log(`\nUsage: node scripts/test_entry_orders_flow_binance.js --symbol ETHUSDT --side long|short --amount 50 --offset_pct 0.5 --confirm\n`);
++  process.exit(msg ? 1 : 0);
++}
++
++async function sleep(ms) {
++  return new Promise(resolve => setTimeout(resolve, ms));
++}
++
++async function getBot3() {
++  const { Bot } = await import('../src/models/Bot.js');
++  const bot = await Bot.findById(3);
++  if (!bot) {
++    throw new Error('Bot id=3 not found in database');
++  }
++  if ((bot.exchange || '').toLowerCase() !== 'binance') {
++    throw new Error(`Bot id=3 must be Binance, got exchange=${bot.exchange}`);
++  }
++  if (!bot.is_active) {
++    throw new Error('Bot id=3 is not active (is_active != 1)');
++  }
++  return bot;
++}
++
++async function getCurrentPrice(exSvc, symbol) {
++  try {
++    const p = await exSvc.getTickerPrice(symbol);
++    if (Number.isFinite(Number(p)) && Number(p) > 0) return Number(p);
++  } catch (_) {}
++
++  try {
++    if (exSvc.binanceDirectClient?.makeMarketDataRequest) {
++      const normalized = exSvc.binanceDirectClient.normalizeSymbol(symbol);
++      const data = await exSvc.binanceDirectClient.makeMarketDataRequest('/fapi/v1/ticker/price', 'GET', { symbol: normalized });
++      const price = Number(data?.price);
++      if (Number.isFinite(price) && price > 0) return price;
++    }
++  } catch (e) {
++    logger.warn(`[test_entry_orders_flow] Market data fallback failed: ${e?.message || e}`);
++  }
++
++  throw new Error(`Cannot fetch current price for ${symbol}`);
++}
++
++async function queryEntryOrdersAndPositions(botId, symbol) {
++  const [entryRows] = await pool.execute(
++    `SELECT * FROM entry_orders WHERE bot_id = ? AND symbol = ? ORDER BY id DESC LIMIT 5`,
++    [botId, symbol]
++  );
++  const [posRows] = await pool.execute(
++    `SELECT * FROM positions WHERE bot_id = ? AND symbol = ? AND status = 'open' ORDER BY id DESC LIMIT 5`,
++    [botId, symbol]
++  );
++  return { entryRows, posRows };
++}
++
++async function createTempStrategy(botId, symbol, amount) {
++  const [result] = await pool.execute(
++    `INSERT INTO strategies (bot_id, symbol, \`interval\`, amount, oc, take_profit, reduce, extend, up_reduce, \`ignore\`, is_active, created_at, updated_at)
++     VALUES (?, ?, '15m', ?, 1, 50, 10, 0, 0, 0, 0, NOW(), NOW())`, // Provide defaults for all non-nullable fields
++    [botId, symbol, amount]
++  );
++  if (!result.insertId) {
++    throw new Error('Failed to create temporary strategy');
++  }
++  console.log(`[INFO] Created temporary strategy with id=${result.insertId}`);
++  return result.insertId;
++}
++
++async function deleteTempStrategy(strategyId) {
++  if (!strategyId) return;
++  try {
++    const [result] = await pool.execute(
++      `DELETE FROM strategies WHERE id = ?`,
++      [strategyId]
++    );
++    if (result.affectedRows > 0) {
++      console.log(`[INFO] Cleaned up temporary strategy id=${strategyId}`);
++    }
++  } catch (e) {
++    console.error(`[ERROR] Failed to clean up temp strategy id=${strategyId}: ${e.message}`);
++  }
++}
++
++async function main() {
++  const symbol = String(args.symbol || 'ETHUSDT').toUpperCase().replace(/[\/:_]/g, '');
++  const side = String(args.side || '').toLowerCase();
++  const amount = Number(args.amount || 50);
++  const offsetPct = Number(args.offset_pct || 0.5);
++  const confirm = !!args.confirm;
++
++  if (!['long', 'short'].includes(side)) usage('Missing/invalid --side');
++  if (!Number.isFinite(amount) || amount <= 0) usage('Missing/invalid --amount');
++
++  let tempStrategyId;
++  try {
++    const bot = await getBot3();
++    console.log(`[INFO] Using bot id=3: name=${bot.bot_name || 'N/A'}, exchange=${bot.exchange}, testnet=${bot.binance_testnet}`);
++
++    tempStrategyId = await createTempStrategy(bot.id, symbol, amount);
++
++    const exSvc = new ExchangeService(bot);
++    await exSvc.initialize();
++
++    const mockTelegramService = {
++      sendMessage: () => Promise.resolve(),
++      sendOrderNotification: () => Promise.resolve(),
++      sendEntryTradeAlert: () => Promise.resolve()
++    };
++
++    const orderSvc = new OrderService(exSvc, mockTelegramService);
++    console.log(`[INFO] Services initialized for bot 3.`);
++
++    const current = await getCurrentPrice(exSvc, symbol);
++    console.log(`[INFO] Current price for ${symbol}: ${current}`);
++
++    let limitPrice;
++    if (side === 'long') {
++      limitPrice = current * (1 - offsetPct / 100);
++    } else {
++      limitPrice = current * (1 + offsetPct / 100);
++    }
++    limitPrice = Number(limitPrice.toFixed(4));
++
++    const realStrategy = {
++      id: tempStrategyId,
++      bot_id: bot.id,
++      symbol: symbol,
++      amount: amount,
++      oc: 1, // Mock value
++      take_profit: 50, // Mock value
++      reduce: 10, // Mock value
++      bot: bot
++    };
++
++    console.log('\n=== Test Plan (Binance testnet entry_orders flow) ===');
++    console.log(`Symbol       : ${symbol}`);
++    console.log(`Side         : ${side.toUpperCase()}`);
++    console.log(`Amount (USDT): ${amount}`);
++    console.log(`Current      : ${current}`);
++    console.log(`Limit Price  : ${limitPrice} (offset ${offsetPct}% from market)`);
++    console.log(`Mode         : ${confirm ? 'CONFIRMED - WILL PLACE REAL LIMIT ORDER' : 'DRY-RUN'}`);
++
++    if (!confirm) {
++      console.log('\nPass --confirm to actually place LIMIT order on Binance testnet.');
++      return; // Exit main, finally will run
++    }
++
++    console.log('\n[0] Snapshot BEFORE placing order: entry_orders + positions');
++    let { entryRows: beforeEntries, posRows: beforePositions } = await queryEntryOrdersAndPositions(bot.id, symbol);
++    console.log('entry_orders(before):', beforeEntries);
++    console.log('positions(open,before):', beforePositions);
++
++    console.log('\n[1] Placing ENTRY LIMIT order via OrderService.executeSignal...');
++    const signal = {
++      strategy: realStrategy,
++      side: side,
++      entryPrice: limitPrice,
++      amount: amount
++    };
++
++    const result = await orderSvc.executeSignal(signal);
++
++    if (!result || (!result.pending && !result.id)) {
++      throw new Error(`Order placement failed or returned invalid result: ${JSON.stringify(result)}`);
++    }
++    const orderId = result.orderId || result.order_id;
++    console.log(`[OK] Order signal executed. Result: ${JSON.stringify(result)}`);
++
++    await sleep(2000);
++
++    console.log('\n[2] Snapshot AFTER placing order (short delay): entry_orders + positions');
++    let { entryRows: afterEntries1, posRows: afterPositions1 } = await queryEntryOrdersAndPositions(bot.id, symbol);
++    console.log('entry_orders(after 2s):', afterEntries1);
++    console.log('positions(open,after 2s):', afterPositions1);
++
++    console.log('\n[3] Waiting 20s for EntryOrderMonitor (WS/REST) to possibly confirm fill/cancel...');
++    await sleep(20000);
++
++    console.log('\n[4] Snapshot AFTER 20s: entry_orders + positions');
++    let { entryRows: afterEntries2, posRows: afterPositions2 } = await queryEntryOrdersAndPositions(bot.id, symbol);
++    console.log('entry_orders(after 20s):', afterEntries2);
++    console.log('positions(open,after 2s):', afterPositions2);
++
++    console.log('\n=== Interpretation Guide ===');
++    console.log('- Nếu LIMIT chưa khớp:');
++    console.log('  + entry_orders: row mới với status="open"');
++    console.log('  + positions: KHÔNG nên có position mới tương ứng.');
++    console.log('- Nếu LIMIT đã khớp trong khoảng thời gian chờ:');
++    console.log('  + entry_orders: status="filled"');
++    console.log('  + positions: có position mới với order_id=' + orderId);
++
++  } finally {
++    await deleteTempStrategy(tempStrategyId);
++    await pool.end();
++    console.log('[INFO] Test finished.');
++  }
++}
++
++main().catch(err => {
++  console.error('Fatal error in test_entry_orders_flow_binance:', err?.message || err);
++  console.error(err?.stack || '');
++  pool.end(); // Ensure pool is closed on error too
++  process.exit(1);
++});
+\ No newline at end of file
+Index: src/jobs/EntryOrderMonitor.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/jobs/EntryOrderMonitor.js b/src/jobs/EntryOrderMonitor.js
+new file mode 100644
+--- /dev/null	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
++++ b/src/jobs/EntryOrderMonitor.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -0,0 +1,270 @@
++import cron from 'node-cron';
++import { EntryOrder } from '../models/EntryOrder.js';
++import { Position } from '../models/Position.js';
++import { ExchangeService } from '../services/ExchangeService.js';
++import { PositionWebSocketClient } from '../services/PositionWebSocketClient.js';
++import { DEFAULT_CRON_PATTERNS } from '../config/constants.js';
++import { configService } from '../services/ConfigService.js';
++import logger from '../utils/logger.js';
++
++/**
++ * EntryOrderMonitor
++ * - Tracks pending entry orders (especially LIMIT) stored in entry_orders table
++ * - Prefers Binance Futures user-data WebSocket (ORDER_TRADE_UPDATE)
++ * - Fallback to REST polling for all exchanges when WS is not available
++ */
++export class EntryOrderMonitor {
++  constructor() {
++    this.exchangeServices = new Map(); // botId -> ExchangeService
++    this.wsClients = new Map(); // botId -> PositionWebSocketClient (Binance only)
++    this.telegramService = null;
++    this.isRunning = false;
++    this.cronJob = null;
++  }
++
++  /**
++   * Initialize services for all active bots
++   */
++  async initialize(telegramService) {
++    this.telegramService = telegramService;
++
++    try {
++      const { Bot } = await import('../models/Bot.js');
++      const bots = await Bot.findAll(true); // Active bots only
++
++      for (const bot of bots) {
++        await this._addBot(bot);
++      }
++    } catch (error) {
++      logger.error('[EntryOrderMonitor] Failed to initialize:', error);
++    }
++  }
++
++  async _addBot(bot) {
++    try {
++      const exchangeService = new ExchangeService(bot);
++      await exchangeService.initialize();
++      this.exchangeServices.set(bot.id, exchangeService);
++
++      // Binance-only: start user-data WebSocket for ORDER_TRADE_UPDATE
++      if ((bot.exchange || '').toLowerCase() === 'binance' && exchangeService.binanceDirectClient) {
++        const restMakeRequest = exchangeService.binanceDirectClient.makeRequest.bind(exchangeService.binanceDirectClient);
++        const isTestnet = !!exchangeService.binanceDirectClient.isTestnet;
++        const wsClient = new PositionWebSocketClient(restMakeRequest, isTestnet);
++
++        wsClient.on('ORDER_TRADE_UPDATE', (evt) => {
++          this._handleBinanceOrderTradeUpdate(bot.id, evt).catch(err => {
++            logger.error(`[EntryOrderMonitor] Error in ORDER_TRADE_UPDATE handler for bot ${bot.id}:`, err?.message || err);
++          });
++        });
++
++        wsClient.on('listenKeyExpired', () => {
++          logger.warn(`[EntryOrderMonitor] listenKeyExpired for bot ${bot.id}, WS client will reconnect.`);
++        });
++
++        wsClient.on('raw', (evt) => {
++          // Optional raw logging / debugging
++          const eType = evt?.e || evt?.eventType;
++          if (eType === 'ORDER_TRADE_UPDATE') {
++            logger.debug(`[EntryOrderMonitor] ORDER_TRADE_UPDATE raw event received for bot ${bot.id}`);
++          }
++        });
++
++        await wsClient.connect();
++        this.wsClients.set(bot.id, wsClient);
++        logger.info(`[EntryOrderMonitor] User-data WebSocket connected for bot ${bot.id}`);
++      }
++
++      logger.info(`[EntryOrderMonitor] Initialized for bot ${bot.id}`);
++    } catch (error) {
++      logger.error(`[EntryOrderMonitor] Failed to initialize for bot ${bot.id}:`, error);
++    }
++  }
++
++  /**
++   * Handle Binance ORDER_TRADE_UPDATE user-data event
++   * @param {number} botId
++   * @param {Object} evt
++   */
++  async _handleBinanceOrderTradeUpdate(botId, evt) {
++    try {
++      const e = evt?.e || evt?.eventType;
++      if (e !== 'ORDER_TRADE_UPDATE') return;
++
++      const o = evt.o || evt.order || {};
++      const orderId = o.i ?? o.orderId; // i: orderId in futures stream
++      const symbol = o.s || o.symbol;
++      const status = o.X || o.orderStatus; // NEW, PARTIALLY_FILLED, FILLED, CANCELED, EXPIRED
++      const avgPriceStr = o.ap ?? o.avgPrice ?? o.p ?? o.price ?? null;
++      const avgPrice = avgPriceStr ? Number(avgPriceStr) : NaN;
++      const filledQtyStr = o.z ?? o.cumQty ?? o.filledQty ?? null;
++      const filledQty = filledQtyStr ? Number(filledQtyStr) : NaN;
++
++      if (!orderId || !symbol) return;
++
++      const normalizedStatus = String(status || '').toUpperCase();
++      const isFilled = normalizedStatus === 'FILLED';
++      const isCanceled = normalizedStatus === 'CANCELED' || normalizedStatus === 'CANCELLED' || normalizedStatus === 'EXPIRED';
++
++      const entry = await EntryOrder.findOpenByBotAndOrder(botId, orderId);
++      if (!entry) {
++        return; // Not an entry order we track
++      }
++
++      if (isFilled) {
++        // Confirmed filled → create Position and mark entry_orders as filled
++        await this._confirmEntryWithPosition(botId, entry, isNaN(avgPrice) || avgPrice <= 0 ? null : avgPrice);
++      } else if (isCanceled && (!Number.isFinite(filledQty) || filledQty <= 0)) {
++        // Cancelled/expired without fill → mark as canceled
++        await EntryOrder.markCanceled(entry.id, normalizedStatus === 'EXPIRED' ? 'expired' : 'canceled');
++        logger.info(`[EntryOrderMonitor] Entry order ${entry.id} (orderId=${orderId}, ${symbol}) canceled/expired on Binance (user-data WS).`);
++      }
++    } catch (error) {
++      logger.error('[EntryOrderMonitor] Error in _handleBinanceOrderTradeUpdate:', error?.message || error);
++    }
++  }
++
++  /**
++   * Fallback polling using REST for all exchanges
++   */
++  async pollOpenEntryOrders() {
++    try {
++      const openEntries = await EntryOrder.findOpen();
++      if (!openEntries.length) return;
++
++      logger.debug(`[EntryOrderMonitor] Polling ${openEntries.length} open entry orders via REST.`);
++
++      for (const entry of openEntries) {
++        try {
++          const exchangeService = this.exchangeServices.get(entry.bot_id);
++          if (!exchangeService) continue;
++
++          const st = await exchangeService.getOrderStatus(entry.symbol, entry.order_id);
++          const status = (st?.status || '').toLowerCase();
++          const filled = Number(st?.filled || 0);
++
++          if ((status === 'closed' || status === 'filled') && filled > 0) {
++            // Confirmed filled via REST
++            await this._confirmEntryWithPosition(entry.bot_id, entry, null);
++          } else if ((status === 'canceled' || status === 'cancelled' || status === 'expired') && filled === 0) {
++            await EntryOrder.markCanceled(entry.id, status === 'expired' ? 'expired' : 'canceled');
++            logger.info(`[EntryOrderMonitor] Entry order ${entry.id} (orderId=${entry.order_id}, ${entry.symbol}) canceled/expired via REST polling.`);
++          }
++        } catch (inner) {
++          logger.warn(`[EntryOrderMonitor] Failed to poll entry order ${entry.id} (${entry.symbol}): ${inner?.message || inner}`);
++        }
++      }
++    } catch (error) {
++      logger.error('[EntryOrderMonitor] Error in pollOpenEntryOrders:', error?.message || error);
++    }
++  }
++
++  /**
++   * Confirm entry order by creating Position and marking entry_orders as filled
++   * @param {number} botId
++   * @param {Object} entry
++   * @param {number|null} overrideEntryPrice
++   */
++  async _confirmEntryWithPosition(botId, entry, overrideEntryPrice = null) {
++    try {
++      const { Strategy } = await import('../models/Strategy.js');
++      const strategy = await Strategy.findById(entry.strategy_id);
++      if (!strategy) {
++        logger.warn(`[EntryOrderMonitor] Strategy ${entry.strategy_id} not found for entry order ${entry.id}, marking as canceled.`);
++        await EntryOrder.markCanceled(entry.id, 'canceled');
++        return;
++      }
++
++      const effectiveEntryPrice = Number.isFinite(overrideEntryPrice) && overrideEntryPrice > 0
++        ? overrideEntryPrice
++        : Number(entry.entry_price);
++
++      const { calculateTakeProfit, calculateInitialStopLoss } = await import('../utils/calculator.js');
++      const side = entry.side;
++      const tpPrice = calculateTakeProfit(effectiveEntryPrice, strategy.oc, strategy.take_profit, side);
++      const slPrice = calculateInitialStopLoss(tpPrice, strategy.oc, strategy.reduce, side);
++
++      const position = await Position.create({
++        strategy_id: entry.strategy_id,
++        bot_id: botId,
++        order_id: entry.order_id,
++        symbol: entry.symbol,
++        side: side,
++        entry_price: effectiveEntryPrice,
++        amount: entry.amount,
++        take_profit_price: tpPrice,
++        stop_loss_price: slPrice,
++        current_reduce: strategy.reduce
++      });
++
++      await EntryOrder.markFilled(entry.id);
++
++      logger.info(`[EntryOrderMonitor] ✅ Confirmed entry order ${entry.id} as Position ${position.id} (${entry.symbol}) at entry=${effectiveEntryPrice}`);
++
++      // Notify via Telegram (same as in OrderService)
++      try {
++        if (this.telegramService?.sendOrderNotification) {
++          await this.telegramService.sendOrderNotification(position, strategy);
++        }
++
++        if (!strategy.bot && strategy.bot_id) {
++          const { Bot } = await import('../models/Bot.js');
++          strategy.bot = await Bot.findById(strategy.bot_id);
++        }
++
++        if (this.telegramService?.sendEntryTradeAlert) {
++          await this.telegramService.sendEntryTradeAlert(position, strategy, strategy.oc);
++        }
++      } catch (e) {
++        logger.warn(`[EntryOrderMonitor] Failed to send Telegram notifications for Position ${position.id}: ${e?.message || e}`);
++      }
++    } catch (error) {
++      logger.error(`[EntryOrderMonitor] Error confirming entry order ${entry.id}:`, error?.message || error);
++    }
++  }
++
++  /**
++   * Start cron-based REST polling
++   */
++  start() {
++    if (this.isRunning) {
++      logger.warn('[EntryOrderMonitor] Already running');
++      return;
++    }
++
++    this.isRunning = true;
++
++    const defaultPattern = DEFAULT_CRON_PATTERNS.POSITION_MONITOR || '*/1 * * * *';
++    const cronPattern = configService.getString('ENTRY_ORDER_MONITOR_CRON', defaultPattern);
++
++    this.cronJob = cron.schedule(cronPattern, async () => {
++      await this.pollOpenEntryOrders();
++    });
++
++    logger.info(`[EntryOrderMonitor] Started with cron pattern: ${cronPattern}`);
++  }
++
++  /**
++   * Stop monitor
++   */
++  stop() {
++    if (!this.isRunning) return;
++    this.isRunning = false;
++
++    if (this.cronJob) {
++      this.cronJob.stop();
++      this.cronJob = null;
++    }
++
++    for (const [, ws] of this.wsClients.entries()) {
++      try {
++        ws.stop();
++      } catch (_) {}
++    }
++    this.wsClients.clear();
++
++    logger.info('[EntryOrderMonitor] Stopped');
++  }
++}
++
++
+Index: src/models/EntryOrder.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/models/EntryOrder.js b/src/models/EntryOrder.js
+new file mode 100644
+--- /dev/null	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
++++ b/src/models/EntryOrder.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -0,0 +1,133 @@
++import pool from '../config/database.js';
++
++/**
++ * EntryOrder model
++ * - Tracks entry orders (especially LIMIT) before a real position is confirmed open on the exchange.
++ */
++export class EntryOrder {
++  /**
++   * Create new entry order
++   * @param {Object} data
++   * @returns {Promise<Object>}
++   */
++  static async create(data) {
++    const {
++      strategy_id,
++      bot_id,
++      order_id,
++      symbol,
++      side,
++      amount,
++      entry_price,
++      status = 'open'
++    } = data;
++
++    const [result] = await pool.execute(
++      `INSERT INTO entry_orders (
++        strategy_id, bot_id, order_id, symbol, side, amount, entry_price, status
++      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
++      [
++        strategy_id,
++        bot_id,
++        String(order_id),
++        symbol,
++        side,
++        amount,
++        entry_price,
++        status
++      ]
++    );
++
++    return this.findById(result.insertId);
++  }
++
++  /**
++   * Find by primary key
++   * @param {number} id
++   * @returns {Promise<Object|null>}
++   */
++  static async findById(id) {
++    const [rows] = await pool.execute(
++      `SELECT * FROM entry_orders WHERE id = ? LIMIT 1`,
++      [id]
++    );
++    return rows[0] || null;
++  }
++
++  /**
++   * Find open entry orders (status = 'open')
++   * @returns {Promise<Array>}
++   */
++  static async findOpen() {
++    const [rows] = await pool.execute(
++      `SELECT * FROM entry_orders WHERE status = 'open' ORDER BY created_at ASC`
++    );
++    return rows;
++  }
++
++  /**
++   * Find open entry order by bot and order id
++   * @param {number} botId
++   * @param {string|number} orderId
++   * @returns {Promise<Object|null>}
++   */
++  static async findOpenByBotAndOrder(botId, orderId) {
++    const [rows] = await pool.execute(
++      `SELECT * FROM entry_orders WHERE bot_id = ? AND order_id = ? AND status = 'open' LIMIT 1`,
++      [botId, String(orderId)]
++    );
++    return rows[0] || null;
++  }
++
++  /**
++   * Update entry order
++   * @param {number} id
++   * @param {Object} data
++   * @returns {Promise<Object>}
++   */
++  static async update(id, data) {
++    const fields = [];
++    const values = [];
++
++    for (const key in data) {
++      if (Object.hasOwn(data, key) && data[key] !== undefined) {
++        fields.push(`\`${key}\` = ?`);
++        values.push(data[key]);
++      }
++    }
++
++    if (fields.length === 0) {
++      return this.findById(id);
++    }
++
++    values.push(id);
++    await pool.execute(
++      `UPDATE entry_orders SET ${fields.join(', ')} WHERE id = ?`,
++      values
++    );
++
++    return this.findById(id);
++  }
++
++  /**
++   * Mark entry order as filled
++   * @param {number} id
++   * @returns {Promise<Object>}
++   */
++  static async markFilled(id) {
++    return this.update(id, { status: 'filled' });
++  }
++
++  /**
++   * Mark entry order as canceled / expired
++   * @param {number} id
++   * @param {string} status - 'canceled' | 'expired'
++   * @returns {Promise<Object>}
++   */
++  static async markCanceled(id, status = 'canceled') {
++    const safeStatus = ['canceled', 'expired'].includes(status) ? status : 'canceled';
++    return this.update(id, { status: safeStatus });
++  }
++}
++
++
+Index: src/services/OrderService.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/services/OrderService.js b/src/services/OrderService.js
+--- a/src/services/OrderService.js	(revision a94457e791ca16cddb81a17fed7442a4c5ee801d)
++++ b/src/services/OrderService.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -1,4 +1,5 @@
+ import { Position } from '../models/Position.js';
++import { EntryOrder } from '../models/EntryOrder.js';
+ import { TelegramService } from './TelegramService.js';
+ import { concurrencyManager } from './ConcurrencyManager.js';
+ import logger from '../utils/logger.js';
+@@ -146,59 +147,122 @@
+         return null;
+       }
+ 
+-      // Calculate temporary TP/SL prices based on the initial signal entry price
++      // Determine effective entry price and whether we have confirmed exposure:
++      // - MARKET (or fallback): use avgFillPrice / price / currentPrice
++      // - LIMIT: immediately query order status; if already filled, use real fill price
++      let effectiveEntryPrice = entryPrice;
++      let hasImmediateExposure = false; // true if MARKET or LIMIT already filled
++      try {
++        if (orderType === 'market') {
++          const filled = Number(order?.avgFillPrice || order?.price || currentPrice);
++          if (Number.isFinite(filled) && filled > 0) {
++            effectiveEntryPrice = filled;
++            hasImmediateExposure = true;
++          }
++        } else if (orderType === 'limit') {
++          // Sync confirmation: check if the limit order was filled immediately
++          const st = await this.exchangeService.getOrderStatus(strategy.symbol, order.id);
++          const status = (st?.status || '').toLowerCase();
++          const filledQty = Number(st?.filled || 0);
++
++          if (status === 'closed' || status === 'filled' || filledQty > 0) {
++            // Try to get the precise average fill price
++            const avg = await this.exchangeService.getOrderAverageFillPrice(strategy.symbol, order.id);
++            if (Number.isFinite(avg) && avg > 0) {
++              effectiveEntryPrice = avg;
++              hasImmediateExposure = true;
++              logger.info(`[OrderService] LIMIT order ${order.id} for ${strategy.symbol} filled immediately, using avgFillPrice=${avg} as entry.`);
++            } else {
++              logger.info(`[OrderService] LIMIT order ${order.id} for ${strategy.symbol} filled immediately, fallback to entryPrice=${entryPrice}.`);
++              hasImmediateExposure = true;
++            }
++          } else {
++            logger.info(`[OrderService] LIMIT order ${order.id} for ${strategy.symbol} not filled yet (status=${st?.status || 'n/a'}, filled=${filledQty}). Position will track exposure via guards.`);
++          }
++        }
++      } catch (e) {
++        logger.warn(`[OrderService] Failed to refine entry price from exchange for order ${order?.id} ${strategy.symbol}: ${e?.message || e}`);
++      }
++
++      // Calculate temporary TP/SL prices based on the effective entry price
+       const { calculateTakeProfit, calculateInitialStopLoss } = await import('../utils/calculator.js');
+-      const tempTpPrice = calculateTakeProfit(entryPrice, strategy.oc, strategy.take_profit, side);
++      const tempTpPrice = calculateTakeProfit(effectiveEntryPrice, strategy.oc, strategy.take_profit, side);
+       const tempSlPrice = calculateInitialStopLoss(tempTpPrice, strategy.oc, strategy.reduce, side);
+ 
+-      // Store position in database
+-      const position = await Position.create({
+-        strategy_id: strategy.id,
+-        bot_id: strategy.bot_id,
+-        order_id: order.id,
+-        symbol: strategy.symbol,
+-        side: side,
+-        entry_price: orderType === 'market' ? (Number(order?.avgFillPrice || order?.price || currentPrice)) : entryPrice,
+-        amount: amount,
+-        take_profit_price: tempTpPrice, // Use temporary TP price
+-        stop_loss_price: tempSlPrice, // Use temporary SL price
+-        current_reduce: strategy.reduce
+-      });
++      let position = null;
++
++      if (hasImmediateExposure || orderType === 'market') {
++        // MARKET or immediately-filled LIMIT: create Position right away
++        position = await Position.create({
++          strategy_id: strategy.id,
++          bot_id: strategy.bot_id,
++          order_id: order.id,
++          symbol: strategy.symbol,
++          side: side,
++          entry_price: effectiveEntryPrice,
++          amount: amount,
++          take_profit_price: tempTpPrice, // Use temporary TP price
++          stop_loss_price: tempSlPrice, // Use temporary SL price
++          current_reduce: strategy.reduce
++        });
++      } else {
++        // Pending LIMIT (no confirmed fill yet): track in entry_orders table
++        try {
++          await EntryOrder.create({
++            strategy_id: strategy.id,
++            bot_id: strategy.bot_id,
++            order_id: order.id,
++            symbol: strategy.symbol,
++            side,
++            amount,
++            entry_price: effectiveEntryPrice,
++            status: 'open'
++          });
++          logger.info(`[OrderService] Tracked pending LIMIT entry order ${order.id} for strategy ${strategy.id} in entry_orders table.`);
++        } catch (e) {
++          logger.warn(`[OrderService] Failed to persist entry order ${order.id} into entry_orders: ${e?.message || e}`);
++        }
++      }
+ 
+-      logger.info(`Position opened:`, {
+-        positionId: position.id,
+-        symbol: strategy.symbol,
+-        side,
+-        entryPrice: position.entry_price,
+-        tpPrice,
+-        slPrice
+-      });
++      if (position) {
++        logger.info(`Position opened:`, {
++          positionId: position.id,
++          symbol: strategy.symbol,
++          side,
++          entryPrice: position.entry_price,
++          tpPrice,
++          slPrice
++        });
+ 
+-      // Send Telegram notification to bot chat
+-      await this.telegramService.sendOrderNotification(position, strategy);
++        // Send Telegram notification to bot chat
++        await this.telegramService.sendOrderNotification(position, strategy);
+ 
+-      // Send entry trade alert to central channel
+-      try {
+-        logger.info(`[OrderService] Preparing to send entry trade alert for position ${position.id}`);
+-        // Ensure bot info present
+-        if (!strategy.bot && strategy.bot_id) {
+-          const { Bot } = await import('../models/Bot.js');
+-          strategy.bot = await Bot.findById(strategy.bot_id);
+-          logger.info(`[OrderService] Fetched bot info: ${strategy.bot?.bot_name || 'N/A'}`);
+-        }
+-        logger.info(`[OrderService] Calling sendEntryTradeAlert for position ${position.id}, strategy ${strategy.id}`);
+-        await this.telegramService.sendEntryTradeAlert(position, strategy, signal.oc);
+-        logger.info(`[OrderService] ✅ Entry trade alert sent successfully for position ${position.id}`);
+-      } catch (e) {
+-        logger.error(`[OrderService] Failed to send entry trade channel alert for position ${position.id}:`, e);
+-        logger.error(`[OrderService] Error stack:`, e?.stack);
+-      }
++        // Send entry trade alert to central channel
++        try {
++          logger.info(`[OrderService] Preparing to send entry trade alert for position ${position.id}`);
++          // Ensure bot info present
++          if (!strategy.bot && strategy.bot_id) {
++            const { Bot } = await import('../models/Bot.js');
++            strategy.bot = await Bot.findById(strategy.bot_id);
++            logger.info(`[OrderService] Fetched bot info: ${strategy.bot?.bot_name || 'N/A'}`);
++          }
++          logger.info(`[OrderService] Calling sendEntryTradeAlert for position ${position.id}, strategy ${strategy.id}`);
++          await this.telegramService.sendEntryTradeAlert(position, strategy, signal.oc);
++          logger.info(`[OrderService] ✅ Entry trade alert sent successfully for position ${position.id}`);
++        } catch (e) {
++          logger.error(`[OrderService] Failed to send entry trade channel alert for position ${position.id}:`, e);
++          logger.error(`[OrderService] Error stack:`, e?.stack);
++        }
+ 
+-      // TP/SL creation is now handled by PositionMonitor after entry confirmation.
+-      logger.info(`Entry order placed for position ${position.id}. TP/SL will be placed by PositionMonitor.`);
++        // TP/SL creation is now handled by PositionMonitor after entry confirmation.
++        logger.info(`Entry order placed for position ${position.id}. TP/SL will be placed by PositionMonitor.`);
+ 
+-      // Central log: success
+-      await this.sendCentralLog(`Order Success | bot=${strategy?.bot_id} strat=${strategy?.id} ${strategy?.symbol} ${String(side).toUpperCase()} orderId=${order?.id} posId=${position?.id} type=${orderType} entry=${position.entry_price} tp=${tempTpPrice} sl=${tempSlPrice}`);
++        // Central log: success
++        await this.sendCentralLog(`Order Success | bot=${strategy?.bot_id} strat=${strategy?.id} ${strategy?.symbol} ${String(side).toUpperCase()} orderId=${order?.id} posId=${position?.id} type=${orderType} entry=${position.entry_price} tp=${tempTpPrice} sl=${tempSlPrice}`);
++      } else {
++        // Pending LIMIT only (no DB position yet)
++        await this.sendCentralLog(`Order PendingLimit | bot=${strategy?.bot_id} strat=${strategy?.id} ${strategy?.symbol} ${String(side).toUpperCase()} orderId=${order?.id} type=${orderType} entry=${effectiveEntryPrice} tp=${tempTpPrice} sl=${tempSlPrice}`);
++      }
+ 
+       // Mark reservation as 'released' (position opened)
+       try {
+@@ -206,7 +270,19 @@
+         await concurrencyManager.finalizeReservation(strategy.bot_id, reservationToken, 'released');
+       } catch (_) {}
+ 
+-      return position;
++      // For compatibility with callers (e.g. WebSocketOCConsumer), always return a truthy value on success:
++      // - Position object when exposure is confirmed
++      // - Lightweight descriptor when only entry_orders record exists
++      if (position) {
++        return position;
++      }
++      return {
++        pending: true,
++        orderId: order.id,
++        strategyId: strategy.id,
++        botId: strategy.bot_id,
++        type: orderType
++      };
+     } catch (error) {
+       const msg = error?.message || '';
+       const softErrors = [
+Index: src/workers/StrategiesWorker.js
+IDEA additional info:
+Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
+<+>UTF-8
+===================================================================
+diff --git a/src/workers/StrategiesWorker.js b/src/workers/StrategiesWorker.js
+--- a/src/workers/StrategiesWorker.js	(revision a94457e791ca16cddb81a17fed7442a4c5ee801d)
++++ b/src/workers/StrategiesWorker.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+@@ -1,6 +1,7 @@
+ import { Strategy } from '../models/Strategy.js';
+ import { Bot } from '../models/Bot.js';
+ import { PositionMonitor } from '../jobs/PositionMonitor.js';
++import { EntryOrderMonitor } from '../jobs/EntryOrderMonitor.js';
+ import { BalanceManager } from '../jobs/BalanceManager.js';
+ import { ExchangeService } from '../services/ExchangeService.js';
+ import { OrderService } from '../services/OrderService.js';
+@@ -44,11 +45,16 @@
+       // Initialize OrderServices from active bots
+       await this.initializeOrderServices(telegramService);
+ 
+-      // Initialize Position Monitor
++      // Initialize Position Monitor (confirmed positions)
+       this.positionMonitor = new PositionMonitor();
+       await this.positionMonitor.initialize(telegramService);
+       this.positionMonitor.start();
+ 
++      // Initialize Entry Order Monitor (pending LIMIT orders, user-data WS + REST fallback)
++      this.entryOrderMonitor = new EntryOrderMonitor();
++      await this.entryOrderMonitor.initialize(telegramService);
++      this.entryOrderMonitor.start();
++
+       // Initialize Balance Manager
+       this.balanceManager = new BalanceManager();
+       await this.balanceManager.initialize(telegramService);
Index: migrations/20251219180000-remove-unique-strategy-params.cjs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/migrations/20251219180000-remove-unique-strategy-params.cjs b/migrations/20251219180000-remove-unique-strategy-params.cjs
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/migrations/20251219180000-remove-unique-strategy-params.cjs	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,33 @@
+'use strict';
+
+module.exports = {
+  up: async (queryInterface, Sequelize) => {
+    // Remove unique constraint unique_strategy_params from strategies table
+    try {
+      await queryInterface.removeIndex('strategies', 'unique_strategy_params');
+      console.log('✅ Removed unique constraint unique_strategy_params from strategies table');
+    } catch (error) {
+      // If index doesn't exist, that's okay
+      if (error.message.includes("Unknown key name") || error.message.includes("doesn't exist")) {
+        console.log('⚠️  Constraint unique_strategy_params does not exist, skipping...');
+      } else {
+        throw error;
+      }
+    }
+  },
+
+  down: async (queryInterface, Sequelize) => {
+    // Re-add unique constraint (if needed for rollback)
+    // Note: This might fail if duplicate entries exist
+    try {
+      await queryInterface.addIndex('strategies', ['symbol', 'side', 'interval', 'oc'], {
+        unique: true,
+        name: 'unique_strategy_params'
+      });
+      console.log('✅ Re-added unique constraint unique_strategy_params to strategies table');
+    } catch (error) {
+      console.warn('⚠️  Could not re-add unique constraint:', error.message);
+    }
+  }
+};
+
Index: migrations/20251220000000-add-stoploss-to-strategies.cjs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/migrations/20251220000000-add-stoploss-to-strategies.cjs b/migrations/20251220000000-add-stoploss-to-strategies.cjs
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/migrations/20251220000000-add-stoploss-to-strategies.cjs	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,25 @@
+'use strict';
+
+/**
+ * Migration: Add stoploss column to strategies table
+ * 
+ * This migration adds a stoploss column to the strategies table.
+ * If stoploss > 0, it will be used as the initial stop loss price.
+ * If stoploss <= 0 or NULL, no stop loss will be set.
+ */
+
+module.exports = {
+  up: async (queryInterface, Sequelize) => {
+    await queryInterface.addColumn('strategies', 'stoploss', {
+      type: Sequelize.DECIMAL(10, 2),
+      allowNull: true,
+      defaultValue: null,
+      comment: 'Stop loss percentage (same format as take_profit: e.g., 50 = 5%). If > 0, used to calculate initial SL from entry price. If <= 0 or NULL, no SL is set.'
+    });
+  },
+
+  down: async (queryInterface, Sequelize) => {
+    await queryInterface.removeColumn('strategies', 'stoploss');
+  }
+};
+
Index: scripts/add_stoploss_to_strategies.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/add_stoploss_to_strategies.js b/scripts/add_stoploss_to_strategies.js
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/add_stoploss_to_strategies.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,50 @@
+import { createPool } from 'mysql2/promise';
+import dotenv from 'dotenv';
+
+dotenv.config();
+
+const pool = createPool({
+  host: process.env.DB_HOST || 'localhost',
+  user: process.env.DB_USER || 'root',
+  password: process.env.DB_PASSWORD || '',
+  database: process.env.DB_NAME || 'bot_oc'
+});
+
+async function addStoplossColumn() {
+  try {
+    // Check if column already exists
+    const [columns] = await pool.execute(
+      `SHOW COLUMNS FROM strategies LIKE 'stoploss'`
+    );
+    
+    if (columns.length > 0) {
+      console.log('⚠️  Column stoploss already exists in strategies table, skipping...');
+      return;
+    }
+    
+    // Add stoploss column
+    await pool.execute(
+      `ALTER TABLE strategies 
+       ADD COLUMN stoploss DECIMAL(10, 2) NULL DEFAULT NULL 
+       COMMENT 'Stop loss percentage (same format as take_profit: e.g., 50 = 5%). If > 0, used to calculate initial SL from entry price. If <= 0 or NULL, no SL is set.'`
+    );
+    
+    console.log('✅ Successfully added stoploss column to strategies table');
+  } catch (error) {
+    console.error('❌ Error adding stoploss column:', error.message);
+    throw error;
+  } finally {
+    await pool.end();
+  }
+}
+
+addStoplossColumn()
+  .then(() => {
+    console.log('Migration completed');
+    process.exit(0);
+  })
+  .catch((error) => {
+    console.error('Migration failed:', error);
+    process.exit(1);
+  });
+
Index: scripts/check_all_positions.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/check_all_positions.js b/scripts/check_all_positions.js
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/check_all_positions.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,46 @@
+#!/usr/bin/env node
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+
+dotenv.config();
+
+// Check all positions (including closed)
+const [allRows] = await pool.execute(
+  'SELECT id, bot_id, symbol, side, status, entry_price, stop_loss_price, take_profit_price, minutes_elapsed, opened_at, closed_at, close_reason FROM positions ORDER BY id DESC LIMIT 10'
+);
+
+console.log('\n📊 All Recent Positions (including closed):\n');
+if (allRows.length === 0) {
+  console.log('  No positions found in database.');
+} else {
+  allRows.forEach(r => {
+    console.log(`  ID: ${r.id}`);
+    console.log(`     Bot ID: ${r.bot_id}`);
+    console.log(`     Symbol: ${r.symbol}`);
+    console.log(`     Side: ${r.side}`);
+    console.log(`     Status: ${r.status}`);
+    console.log(`     Entry: ${r.entry_price}`);
+    console.log(`     SL: ${r.stop_loss_price}`);
+    console.log(`     TP: ${r.take_profit_price}`);
+    console.log(`     Minutes Elapsed: ${r.minutes_elapsed || 0}`);
+    console.log(`     Opened At: ${r.opened_at}`);
+    console.log(`     Closed At: ${r.closed_at || 'N/A'}`);
+    console.log(`     Close Reason: ${r.close_reason || 'N/A'}`);
+    console.log('');
+  });
+}
+
+// Check open positions specifically
+const [openRows] = await pool.execute(
+  'SELECT COUNT(*) as count FROM positions WHERE status="open"'
+);
+console.log(`\n📈 Open Positions Count: ${openRows[0].count}`);
+
+// Check closed positions
+const [closedRows] = await pool.execute(
+  'SELECT COUNT(*) as count FROM positions WHERE status="closed"'
+);
+console.log(`📉 Closed Positions Count: ${closedRows[0].count}`);
+
+process.exit(0);
+
Index: scripts/clear_data_test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/clear_data_test.js b/scripts/clear_data_test.js
new file mode 100755
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/clear_data_test.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,201 @@
+#!/usr/bin/env node
+/**
+ * Script: clear_data_test.js
+ * 
+ * Mục đích: Clear data test để đảm bảo test chạy đúng
+ * 
+ * Các bảng sẽ được clear:
+ * 1. positions - positions test (filter theo bot_id hoặc symbol)
+ * 2. entry_orders - entry orders pending (filter theo bot_id hoặc symbol)
+ * 3. concurrency_reservations - reservations (filter theo bot_id)
+ * 4. strategies - strategies test (filter theo bot_id hoặc symbol, chỉ clear inactive)
+ * 
+ * Usage:
+ *   node scripts/clear_data_test.js --bot_id 3
+ *   node scripts/clear_data_test.js --bot_id 3 --symbol BTCUSDT
+ *   node scripts/clear_data_test.js --bot_id 3 --symbol BTCUSDT --confirm
+ */
+
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+import logger from '../src/utils/logger.js';
+
+dotenv.config();
+
+function parseArgs(argv) {
+  const out = {};
+  for (let i = 0; i < argv.length; i++) {
+    const a = argv[i];
+    if (a.startsWith('--')) {
+      const key = a.replace(/^--/, '');
+      const next = argv[i + 1];
+      if (!next || next.startsWith('--')) {
+        out[key] = true;
+      } else {
+        out[key] = next;
+        i++;
+      }
+    }
+  }
+  return out;
+}
+
+const args = parseArgs(process.argv.slice(2));
+
+async function clearTestData() {
+  const botId = args.bot_id ? Number(args.bot_id) : null;
+  const symbol = args.symbol || null;
+  const confirm = args.confirm === true || args.confirm === 'true';
+
+  if (!botId) {
+    console.error('❌ Error: --bot_id is required');
+    console.log('\nUsage:');
+    console.log('  node scripts/clear_data_test.js --bot_id 3');
+    console.log('  node scripts/clear_data_test.js --bot_id 3 --symbol BTCUSDT');
+    console.log('  node scripts/clear_data_test.js --bot_id 3 --symbol BTCUSDT --confirm');
+    process.exit(1);
+  }
+
+  console.log('\n🔍 Analyzing data to be cleared...');
+  console.log(`   Bot ID: ${botId}`);
+  console.log(`   Symbol: ${symbol || 'ALL'}`);
+  console.log(`   Confirm: ${confirm ? 'YES (will delete)' : 'NO (dry-run)'}`);
+
+  try {
+    // 1. Check positions
+    let positionsQuery = 'SELECT COUNT(*) as count FROM positions WHERE bot_id = ?';
+    let positionsParams = [botId];
+    if (symbol) {
+      positionsQuery += ' AND symbol = ?';
+      positionsParams.push(symbol);
+    }
+    const [positionsCount] = await pool.execute(positionsQuery, positionsParams);
+    console.log(`\n📊 Positions: ${positionsCount[0].count} found`);
+
+    // 2. Check entry_orders
+    let entryOrdersQuery = 'SELECT COUNT(*) as count FROM entry_orders WHERE bot_id = ?';
+    let entryOrdersParams = [botId];
+    if (symbol) {
+      entryOrdersQuery += ' AND symbol = ?';
+      entryOrdersParams.push(symbol);
+    }
+    const [entryOrdersCount] = await pool.execute(entryOrdersQuery, entryOrdersParams);
+    console.log(`📊 Entry Orders: ${entryOrdersCount[0].count} found`);
+
+    // 3. Check concurrency_reservations
+    const [reservationsCount] = await pool.execute(
+      'SELECT COUNT(*) as count FROM concurrency_reservations WHERE bot_id = ?',
+      [botId]
+    );
+    console.log(`📊 Concurrency Reservations: ${reservationsCount[0].count} found`);
+
+    // 4. Check strategies (only inactive test strategies)
+    let strategiesQuery = `SELECT COUNT(*) as count FROM strategies 
+                           WHERE bot_id = ? AND is_active = 0`;
+    let strategiesParams = [botId];
+    if (symbol) {
+      strategiesQuery += ' AND symbol = ?';
+      strategiesParams.push(symbol);
+    }
+    const [strategiesCount] = await pool.execute(strategiesQuery, strategiesParams);
+    console.log(`📊 Inactive Strategies: ${strategiesCount[0].count} found`);
+
+    const totalCount = positionsCount[0].count + entryOrdersCount[0].count + 
+                       reservationsCount[0].count + strategiesCount[0].count;
+
+    if (totalCount === 0) {
+      console.log('\n✅ No data to clear. Database is already clean.');
+      return;
+    }
+
+    if (!confirm) {
+      console.log('\n⚠️  DRY-RUN MODE: No data will be deleted.');
+      console.log('   Add --confirm flag to actually delete the data.');
+      console.log(`\n   Would delete:`);
+      console.log(`   - ${positionsCount[0].count} positions`);
+      console.log(`   - ${entryOrdersCount[0].count} entry orders`);
+      console.log(`   - ${reservationsCount[0].count} concurrency reservations`);
+      console.log(`   - ${strategiesCount[0].count} inactive strategies`);
+      return;
+    }
+
+    console.log('\n🗑️  Starting cleanup...');
+
+    // Start transaction
+    const connection = await pool.getConnection();
+    await connection.beginTransaction();
+
+    try {
+      // 1. Delete positions
+      if (positionsCount[0].count > 0) {
+        let deletePositionsQuery = 'DELETE FROM positions WHERE bot_id = ?';
+        let deletePositionsParams = [botId];
+        if (symbol) {
+          deletePositionsQuery += ' AND symbol = ?';
+          deletePositionsParams.push(symbol);
+        }
+        const [posResult] = await connection.execute(deletePositionsQuery, deletePositionsParams);
+        console.log(`✅ Deleted ${posResult.affectedRows} positions`);
+      }
+
+      // 2. Delete entry_orders
+      if (entryOrdersCount[0].count > 0) {
+        let deleteEntryOrdersQuery = 'DELETE FROM entry_orders WHERE bot_id = ?';
+        let deleteEntryOrdersParams = [botId];
+        if (symbol) {
+          deleteEntryOrdersQuery += ' AND symbol = ?';
+          deleteEntryOrdersParams.push(symbol);
+        }
+        const [eoResult] = await connection.execute(deleteEntryOrdersQuery, deleteEntryOrdersParams);
+        console.log(`✅ Deleted ${eoResult.affectedRows} entry orders`);
+      }
+
+      // 3. Delete concurrency_reservations
+      if (reservationsCount[0].count > 0) {
+        const [resResult] = await connection.execute(
+          'DELETE FROM concurrency_reservations WHERE bot_id = ?',
+          [botId]
+        );
+        console.log(`✅ Deleted ${resResult.affectedRows} concurrency reservations`);
+      }
+
+      // 4. Delete inactive strategies (test strategies)
+      if (strategiesCount[0].count > 0) {
+        let deleteStrategiesQuery = `DELETE FROM strategies 
+                                     WHERE bot_id = ? AND is_active = 0`;
+        let deleteStrategiesParams = [botId];
+        if (symbol) {
+          deleteStrategiesQuery += ' AND symbol = ?';
+          deleteStrategiesParams.push(symbol);
+        }
+        const [stratResult] = await connection.execute(deleteStrategiesQuery, deleteStrategiesParams);
+        console.log(`✅ Deleted ${stratResult.affectedRows} inactive strategies`);
+      }
+
+      await connection.commit();
+      console.log('\n✅ Cleanup completed successfully!');
+
+    } catch (error) {
+      await connection.rollback();
+      throw error;
+    } finally {
+      connection.release();
+    }
+
+  } catch (error) {
+    logger.error('Failed to clear test data:', error);
+    console.error('\n❌ Error:', error.message);
+    process.exit(1);
+  }
+}
+
+clearTestData()
+  .then(() => {
+    console.log('\n✨ Done.');
+    process.exit(0);
+  })
+  .catch((error) => {
+    console.error('\n❌ Fatal error:', error);
+    process.exit(1);
+  });
+
Index: scripts/debug_sl_movement.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/debug_sl_movement.js b/scripts/debug_sl_movement.js
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/debug_sl_movement.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,172 @@
+#!/usr/bin/env node
+/**
+ * Debug script to analyze why SL is not moving
+ * This script simulates the SL calculation logic without actually calling the exchange
+ */
+
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+import { Position } from '../src/models/Position.js';
+import { PositionService } from '../src/services/PositionService.js';
+import logger from '../src/utils/logger.js';
+
+dotenv.config();
+
+async function debugSLMovement() {
+  try {
+    // Find positions with SL around 88,948 or recent BTC positions
+    const [positions] = await pool.execute(
+      `SELECT p.*, s.reduce, s.up_reduce, s.stoploss, s.oc, s.take_profit
+       FROM positions p
+       JOIN strategies s ON p.strategy_id = s.id
+       WHERE p.bot_id = 3 
+         AND (
+           (p.stop_loss_price BETWEEN 88900 AND 89000)
+           OR (p.side = 'long' AND (p.symbol LIKE '%BTC%' OR p.symbol = 'BTCUSDT'))
+         )
+       ORDER BY p.opened_at DESC
+       LIMIT 5`
+    );
+    
+    console.log(`Found ${positions.length} BTC LONG positions\n`);
+
+    if (positions.length === 0) {
+      console.log('❌ No BTC LONG positions found for bot 3');
+      return;
+    }
+
+    // Analyze all positions found
+    for (let idx = 0; idx < positions.length; idx++) {
+      const position = positions[idx];
+      console.log(`\n${'='.repeat(60)}`);
+      console.log(`POSITION ${idx + 1}/${positions.length}`);
+      console.log(`${'='.repeat(60)}`);
+    console.log('\n=== POSITION ANALYSIS ===');
+    console.log(`Position ID: ${position.id}`);
+    console.log(`Symbol: ${position.symbol}`);
+    console.log(`Side: ${position.side}`);
+    console.log(`Entry Price: ${position.entry_price}`);
+    console.log(`Current SL: ${position.stop_loss_price || 'NULL'}`);
+    console.log(`TP Price: ${position.take_profit_price}`);
+    console.log(`Opened At: ${position.opened_at}`);
+    console.log(`Minutes Elapsed (DB): ${position.minutes_elapsed || 0}`);
+    console.log(`Reduce: ${position.reduce || 'NULL'}`);
+    console.log(`Up Reduce: ${position.up_reduce || 'NULL'}`);
+    console.log(`Stoploss: ${position.stoploss || 'NULL'}`);
+
+    // Calculate actual minutes elapsed
+    const openedAt = position.opened_at ? new Date(position.opened_at).getTime() : null;
+    const now = Date.now();
+    const actualMinutesElapsed = openedAt ? Math.floor((now - openedAt) / (60 * 1000)) : null;
+    
+    console.log('\n=== TIMING ANALYSIS ===');
+    console.log(`Opened At (timestamp): ${openedAt || 'NULL'}`);
+    console.log(`Current Time: ${now}`);
+    console.log(`Time Difference: ${openedAt ? (now - openedAt) : 'N/A'}ms (${openedAt ? Math.floor((now - openedAt) / 1000) : 'N/A'}s)`);
+    console.log(`Actual Minutes Elapsed: ${actualMinutesElapsed !== null ? actualMinutesElapsed : 'N/A'}`);
+    console.log(`DB Minutes Elapsed: ${position.minutes_elapsed || 0}`);
+    
+    if (actualMinutesElapsed !== null) {
+      console.log(`Minutes Difference: ${actualMinutesElapsed - (position.minutes_elapsed || 0)}`);
+      if (actualMinutesElapsed <= (position.minutes_elapsed || 0)) {
+        console.log(`⚠️  WARNING: Actual minutes (${actualMinutesElapsed}) <= DB minutes (${position.minutes_elapsed || 0}) - SL will NOT move!`);
+      }
+    } else {
+      console.log(`⚠️  WARNING: opened_at is NULL - cannot calculate actual minutes!`);
+    }
+
+    // Test calculateUpdatedStopLoss
+    console.log('\n=== SL CALCULATION TEST ===');
+    const positionService = new PositionService(null);
+    
+    // Test with current position
+    const currentSL = positionService.calculateUpdatedStopLoss(position);
+    console.log(`Current SL calculation result: ${currentSL}`);
+    
+    // Test with incremented minutes
+    if (actualMinutesElapsed !== null && actualMinutesElapsed > (position.minutes_elapsed || 0)) {
+      const testPosition = {
+        ...position,
+        minutes_elapsed: actualMinutesElapsed
+      };
+      const newSL = positionService.calculateUpdatedStopLoss(testPosition);
+      console.log(`New SL calculation (with minutes=${actualMinutesElapsed}): ${newSL}`);
+      
+      if (newSL && newSL !== currentSL) {
+        const stepValue = Number(position.entry_price) * ((Number(position.up_reduce) / 10) / 100);
+        console.log(`Expected step value: ${stepValue.toFixed(2)}`);
+        console.log(`Actual change: ${Math.abs(newSL - (Number(position.stop_loss_price) || 0)).toFixed(2)}`);
+      } else {
+        console.log(`⚠️  WARNING: New SL (${newSL}) is same as current SL (${currentSL}) or NULL!`);
+      }
+    }
+
+    // Check if up_reduce is valid
+    console.log('\n=== PARAMETER VALIDATION ===');
+    const upReduce = Number(position.up_reduce || 0);
+    const reduce = Number(position.reduce || 0);
+    const stoploss = Number(position.stoploss || 0);
+    const entryPrice = Number(position.entry_price || 0);
+    const prevSL = Number(position.stop_loss_price || 0);
+    
+    console.log(`Entry Price valid: ${Number.isFinite(entryPrice) && entryPrice > 0}`);
+    console.log(`Up Reduce valid: ${Number.isFinite(upReduce) && upReduce > 0} (value: ${upReduce})`);
+    console.log(`Reduce valid: ${Number.isFinite(reduce) && reduce > 0} (value: ${reduce})`);
+    console.log(`Stoploss valid: ${Number.isFinite(stoploss) && stoploss > 0} (value: ${stoploss})`);
+    console.log(`Previous SL valid: ${Number.isFinite(prevSL) && prevSL > 0} (value: ${prevSL})`);
+    
+    if (!Number.isFinite(upReduce) || upReduce <= 0) {
+      console.log(`❌ PROBLEM: up_reduce is invalid (${upReduce}) - SL will NOT move for LONG position!`);
+    }
+    
+    if (!Number.isFinite(prevSL) || prevSL <= 0) {
+      console.log(`⚠️  WARNING: No previous SL (${prevSL}) - need initial SL from stoploss`);
+      if (!Number.isFinite(stoploss) || stoploss <= 0) {
+        console.log(`❌ PROBLEM: stoploss is invalid (${stoploss}) - cannot calculate initial SL!`);
+      }
+    }
+
+    // Calculate expected step value
+    if (Number.isFinite(upReduce) && upReduce > 0 && Number.isFinite(entryPrice) && entryPrice > 0) {
+      const actualReducePercent = upReduce / 10; // 5 -> 0.5%
+      const stepValue = entryPrice * (actualReducePercent / 100);
+      console.log(`\n=== EXPECTED MOVEMENT ===`);
+      console.log(`Up Reduce: ${upReduce} (${actualReducePercent}%)`);
+      console.log(`Step Value: ${stepValue.toFixed(2)} USDT per minute`);
+      console.log(`Current SL: ${prevSL || 'NULL'}`);
+      if (prevSL > 0) {
+        console.log(`Expected Next SL: ${(prevSL + stepValue).toFixed(2)}`);
+      }
+    }
+
+    console.log('\n=== RECOMMENDATIONS ===');
+    if (!openedAt) {
+      console.log('1. ❌ opened_at is NULL - Position may not have opened_at timestamp set');
+      console.log('   Fix: Ensure opened_at is set when creating position');
+    }
+    if (!Number.isFinite(upReduce) || upReduce <= 0) {
+      console.log('2. ❌ up_reduce is invalid - SL cannot move for LONG position');
+      console.log('   Fix: Set up_reduce > 0 in strategy');
+    }
+    if (!Number.isFinite(prevSL) || prevSL <= 0) {
+      console.log('3. ⚠️  No previous SL - Need initial SL from stoploss');
+      if (!Number.isFinite(stoploss) || stoploss <= 0) {
+        console.log('   Fix: Set stoploss > 0 in strategy to create initial SL');
+      }
+    }
+    if (actualMinutesElapsed !== null && actualMinutesElapsed <= (position.minutes_elapsed || 0)) {
+      console.log('4. ⚠️  Actual minutes <= DB minutes - Not yet time for next step');
+      console.log(`   Wait: ${60 - ((now - openedAt) % 60000) / 1000} seconds until next minute`);
+    }
+    } // End of position loop
+
+  } catch (error) {
+    console.error('Error:', error);
+    console.error(error.stack);
+  } finally {
+    await pool.end();
+  }
+}
+
+debugSLMovement();
+
Index: scripts/list_open_positions.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/list_open_positions.js b/scripts/list_open_positions.js
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/list_open_positions.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,28 @@
+#!/usr/bin/env node
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+
+dotenv.config();
+
+const [rows] = await pool.execute(
+  'SELECT id, symbol, side, entry_price, stop_loss_price, minutes_elapsed, opened_at FROM positions WHERE status="open" ORDER BY id DESC LIMIT 5'
+);
+
+console.log('\n📊 Recent Open Positions:\n');
+if (rows.length === 0) {
+  console.log('  No open positions found.');
+} else {
+  rows.forEach(r => {
+    console.log(`  ID: ${r.id}`);
+    console.log(`     Symbol: ${r.symbol}`);
+    console.log(`     Side: ${r.side}`);
+    console.log(`     Entry: ${r.entry_price}`);
+    console.log(`     SL: ${r.stop_loss_price}`);
+    console.log(`     Minutes Elapsed: ${r.minutes_elapsed || 0}`);
+    console.log(`     Opened At: ${r.opened_at}`);
+    console.log('');
+  });
+}
+
+process.exit(0);
+
Index: scripts/monitor_sl_movement.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/monitor_sl_movement.js b/scripts/monitor_sl_movement.js
new file mode 100755
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/monitor_sl_movement.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,220 @@
+#!/usr/bin/env node
+/**
+ * Script: monitor_sl_movement.js
+ * 
+ * Mục đích: Monitor SL movement của một position trong thời gian dài để verify trailing logic
+ * 
+ * Usage:
+ *   node scripts/monitor_sl_movement.js --position_id 1
+ *   node scripts/monitor_sl_movement.js --position_id 1 --duration 180 (monitor 3 phút)
+ */
+
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+import logger from '../src/utils/logger.js';
+import { PositionMonitor } from '../src/jobs/PositionMonitor.js';
+import { Position } from '../src/models/Position.js';
+import { ExchangeService } from '../src/services/ExchangeService.js';
+
+dotenv.config();
+
+function parseArgs(argv) {
+  const out = {};
+  for (let i = 0; i < argv.length; i++) {
+    const a = argv[i];
+    if (a.startsWith('--')) {
+      const key = a.replace(/^--/, '');
+      const next = argv[i + 1];
+      if (!next || next.startsWith('--')) {
+        out[key] = true;
+      } else {
+        out[key] = next;
+        i++;
+      }
+    }
+  }
+  return out;
+}
+
+const args = parseArgs(process.argv.slice(2));
+
+async function sleep(ms) {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+
+async function monitorPosition() {
+  const positionId = args.position_id ? Number(args.position_id) : null;
+  const durationSeconds = args.duration ? Number(args.duration) : 180; // Default 3 phút
+  const intervalSeconds = args.interval ? Number(args.interval) : 5; // Check mỗi 5 giây
+
+  if (!positionId) {
+    console.error('❌ Error: --position_id is required');
+    console.log('\nUsage:');
+    console.log('  node scripts/monitor_sl_movement.js --position_id 1');
+    console.log('  node scripts/monitor_sl_movement.js --position_id 1 --duration 180');
+    console.log('  node scripts/monitor_sl_movement.js --position_id 1 --duration 180 --interval 5');
+    process.exit(1);
+  }
+
+  console.log('\n🔍 Starting SL Movement Monitor');
+  console.log(`   Position ID: ${positionId}`);
+  console.log(`   Duration: ${durationSeconds} seconds (${Math.floor(durationSeconds / 60)} minutes)`);
+  console.log(`   Check Interval: ${intervalSeconds} seconds`);
+  console.log('');
+
+  try {
+    // Initialize services
+    const position = await Position.findById(positionId);
+    if (!position) {
+      console.error(`❌ Position ${positionId} not found`);
+      process.exit(1);
+    }
+
+    if (position.status !== 'open') {
+      console.error(`❌ Position ${positionId} is not open (status: ${position.status})`);
+      process.exit(1);
+    }
+
+    const botId = position.bot_id;
+    const exchangeService = new ExchangeService(botId);
+    const posMonitor = new PositionMonitor(botId);
+
+    console.log('📊 Initial Position State:');
+    console.log(`   ID: ${position.id}`);
+    console.log(`   Symbol: ${position.symbol}`);
+    console.log(`   Side: ${position.side}`);
+    console.log(`   Entry Price: ${position.entry_price}`);
+    console.log(`   Take Profit Price: ${position.take_profit_price}`);
+    console.log(`   Stop Loss Price: ${position.stop_loss_price}`);
+    console.log(`   TP Order ID: ${position.tp_order_id || 'N/A'}`);
+    console.log(`   SL Order ID: ${position.sl_order_id || 'N/A'}`);
+    console.log(`   Minutes Elapsed: ${position.minutes_elapsed || 0}`);
+    console.log(`   Reduce: ${position.reduce || 0}`);
+    console.log(`   Up Reduce: ${position.up_reduce || 0}`);
+    console.log(`   Opened At: ${position.opened_at}`);
+    console.log('');
+
+    const startTime = Date.now();
+    const endTime = startTime + (durationSeconds * 1000);
+    let iteration = 0;
+    let prevSL = Number(position.stop_loss_price || 0);
+    let prevMinutes = Number(position.minutes_elapsed || 0);
+    let prevTP = Number(position.take_profit_price || 0);
+
+    console.log('⏱️  Starting monitoring loop...\n');
+    console.log('='.repeat(100));
+
+    while (Date.now() < endTime) {
+      iteration++;
+      const elapsed = Math.floor((Date.now() - startTime) / 1000);
+      const remaining = durationSeconds - elapsed;
+
+      // Reload position from DB
+      const fresh = await Position.findById(positionId);
+      if (!fresh || fresh.status !== 'open') {
+        console.log(`\n⚠️  Position ${positionId} is no longer open (status: ${fresh?.status}). Stopping monitor.`);
+        break;
+      }
+
+      // Get current market price
+      let currentPrice;
+      try {
+        currentPrice = await exchangeService.getCurrentPrice(fresh.symbol);
+      } catch (e) {
+        logger.warn(`Failed to get current price: ${e?.message || e}`);
+        currentPrice = null;
+      }
+
+      const currentSL = Number(fresh.stop_loss_price || 0);
+      const currentTP = Number(fresh.take_profit_price || 0);
+      const currentMinutes = Number(fresh.minutes_elapsed || 0);
+
+      // Calculate time since position opened
+      const openedAt = fresh.opened_at ? new Date(fresh.opened_at).getTime() : null;
+      const actualMinutesElapsed = openedAt ? Math.floor((Date.now() - openedAt) / (60 * 1000)) : null;
+
+      // Check for changes
+      const slChanged = Math.abs(currentSL - prevSL) > 0.01;
+      const tpChanged = Math.abs(currentTP - prevTP) > 0.01;
+      const minutesChanged = currentMinutes !== prevMinutes;
+
+      // Display status
+      const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
+      console.log(`\n[${timestamp}] Iteration ${iteration} | Elapsed: ${elapsed}s | Remaining: ${remaining}s`);
+      console.log(`  Current Price: ${currentPrice ? currentPrice.toFixed(2) : 'N/A'}`);
+      console.log(`  Stop Loss: ${currentSL.toFixed(2)} ${slChanged ? `(CHANGED from ${prevSL.toFixed(2)})` : ''}`);
+      console.log(`  Take Profit: ${currentTP.toFixed(2)} ${tpChanged ? `(CHANGED from ${prevTP.toFixed(2)})` : ''}`);
+      console.log(`  Minutes Elapsed (DB): ${currentMinutes} ${minutesChanged ? `(CHANGED from ${prevMinutes})` : ''}`);
+      console.log(`  Minutes Elapsed (Actual): ${actualMinutesElapsed !== null ? actualMinutesElapsed : 'N/A'}`);
+      console.log(`  TP Order ID: ${fresh.tp_order_id || 'N/A'}`);
+      console.log(`  SL Order ID: ${fresh.sl_order_id || 'N/A'}`);
+
+      if (slChanged || tpChanged || minutesChanged) {
+        console.log(`  ✅ CHANGES DETECTED!`);
+        if (slChanged) {
+          const slDelta = currentSL - prevSL;
+          const slDeltaPercent = ((slDelta / prevSL) * 100).toFixed(4);
+          console.log(`     SL moved: ${prevSL.toFixed(2)} → ${currentSL.toFixed(2)} (Δ${slDelta > 0 ? '+' : ''}${slDelta.toFixed(2)}, ${slDeltaPercent > 0 ? '+' : ''}${slDeltaPercent}%)`);
+        }
+        if (tpChanged) {
+          const tpDelta = currentTP - prevTP;
+          const tpDeltaPercent = ((tpDelta / prevTP) * 100).toFixed(4);
+          console.log(`     TP moved: ${prevTP.toFixed(2)} → ${currentTP.toFixed(2)} (Δ${tpDelta > 0 ? '+' : ''}${tpDelta.toFixed(2)}, ${tpDeltaPercent > 0 ? '+' : ''}${tpDeltaPercent}%)`);
+        }
+        if (minutesChanged) {
+          console.log(`     Minutes elapsed: ${prevMinutes} → ${currentMinutes}`);
+        }
+      } else {
+        console.log(`  ⏳ No changes detected`);
+      }
+
+      // Update previous values
+      prevSL = currentSL;
+      prevTP = currentTP;
+      prevMinutes = currentMinutes;
+
+      // Call monitorPosition to trigger updates
+      try {
+        await posMonitor.monitorPosition(fresh);
+      } catch (e) {
+        logger.error(`Error in monitorPosition: ${e?.message || e}`);
+      }
+
+      // Wait before next iteration
+      if (remaining > 0) {
+        await sleep(intervalSeconds * 1000);
+      }
+    }
+
+    console.log('\n' + '='.repeat(100));
+    console.log('\n✅ Monitoring completed!');
+    console.log(`   Total iterations: ${iteration}`);
+    console.log(`   Total duration: ${Math.floor((Date.now() - startTime) / 1000)} seconds`);
+
+    // Final state
+    const final = await Position.findById(positionId);
+    if (final) {
+      console.log('\n📊 Final Position State:');
+      console.log(`   Stop Loss Price: ${final.stop_loss_price || 'N/A'}`);
+      console.log(`   Take Profit Price: ${final.take_profit_price || 'N/A'}`);
+      console.log(`   Minutes Elapsed: ${final.minutes_elapsed || 0}`);
+      console.log(`   Status: ${final.status}`);
+    }
+
+  } catch (error) {
+    logger.error('Failed to monitor position:', error);
+    console.error('\n❌ Error:', error.message);
+    process.exit(1);
+  }
+}
+
+monitorPosition()
+  .then(() => {
+    console.log('\n✨ Done.');
+    process.exit(0);
+  })
+  .catch((error) => {
+    console.error('\n❌ Fatal error:', error);
+    process.exit(1);
+  });
+
Index: scripts/remove_unique_strategy_params.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/remove_unique_strategy_params.js b/scripts/remove_unique_strategy_params.js
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/remove_unique_strategy_params.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,50 @@
+import { createPool } from 'mysql2/promise';
+import dotenv from 'dotenv';
+
+dotenv.config();
+
+const pool = createPool({
+  host: process.env.DB_HOST || 'localhost',
+  user: process.env.DB_USER || 'root',
+  password: process.env.DB_PASSWORD || '',
+  database: process.env.DB_NAME || 'bot_oc'
+});
+
+async function removeUniqueConstraint() {
+  try {
+    // Check if constraint exists
+    const [rows] = await pool.execute(
+      `SHOW INDEX FROM strategies WHERE Key_name = 'unique_strategy_params'`
+    );
+    
+    if (rows.length > 0) {
+      // Remove the unique constraint
+      await pool.execute(
+        `ALTER TABLE strategies DROP INDEX unique_strategy_params`
+      );
+      console.log('✅ Successfully removed unique constraint unique_strategy_params from strategies table');
+    } else {
+      console.log('⚠️  Constraint unique_strategy_params does not exist, skipping...');
+    }
+  } catch (error) {
+    if (error.message.includes("Unknown key name") || error.message.includes("doesn't exist")) {
+      console.log('⚠️  Constraint unique_strategy_params does not exist, skipping...');
+    } else {
+      console.error('❌ Error removing constraint:', error.message);
+      throw error;
+    }
+  } finally {
+    await pool.end();
+  }
+}
+
+removeUniqueConstraint()
+  .then(() => {
+    console.log('Migration completed');
+    process.exit(0);
+  })
+  .catch((error) => {
+    console.error('Migration failed:', error);
+    process.exit(1);
+  });
+
Index: scripts/test_and_monitor_sl.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/test_and_monitor_sl.js b/scripts/test_and_monitor_sl.js
new file mode 100755
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/test_and_monitor_sl.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,300 @@
+#!/usr/bin/env node
+/**
+ * Script: test_and_monitor_sl.js
+ * 
+ * Mục đích: Tạo position và monitor SL movement ngay sau đó
+ * 
+ * Usage:
+ *   node scripts/test_and_monitor_sl.js --bot_id 3 --symbol BTC --side long --amount 200 --reduce 5 --up_reduce 5 --confirm
+ */
+
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+import logger from '../src/utils/logger.js';
+import { ExchangeService } from '../src/services/ExchangeService.js';
+import { OrderService } from '../src/services/OrderService.js';
+import { PositionMonitor } from '../src/jobs/PositionMonitor.js';
+import { Position } from '../src/models/Position.js';
+import { Bot } from '../src/models/Bot.js';
+
+dotenv.config();
+
+function parseArgs(argv) {
+  const out = {};
+  for (let i = 0; i < argv.length; i++) {
+    const a = argv[i];
+    if (a.startsWith('--')) {
+      const key = a.replace(/^--/, '');
+      const next = argv[i + 1];
+      if (!next || next.startsWith('--')) {
+        out[key] = true;
+      } else {
+        out[key] = next;
+        i++;
+      }
+    }
+  }
+  return out;
+}
+
+const args = parseArgs(process.argv.slice(2));
+
+async function sleep(ms) {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+
+async function createTempStrategy(botId, symbol, amountUSDT, reduce, upReduce) {
+  try {
+    await pool.execute(
+      `DELETE FROM strategies 
+       WHERE bot_id = ? AND symbol = ? AND \`interval\` = '15m' AND oc = 2 AND take_profit = 20 
+       AND is_active = 0`,
+      [botId, symbol]
+    );
+  } catch (e) {
+    // Ignore cleanup errors
+  }
+  
+  const [res] = await pool.execute(
+    `INSERT INTO strategies (bot_id, symbol, \`interval\`, amount, oc, take_profit, reduce, extend, up_reduce, \`ignore\`, is_active, created_at, updated_at)
+     VALUES (?, ?, '15m', ?, 2, 20, ?, 0, ?, 0, 0, NOW(), NOW())`,
+    [botId, symbol, amountUSDT, reduce, upReduce]
+  );
+  return res.insertId;
+}
+
+async function main() {
+  const botId = args.bot_id ? Number(args.bot_id) : 3;
+  let symbol = args.symbol || 'BTCUSDT';
+  // Normalize symbol: BTC -> BTCUSDT
+  if (symbol === 'BTC') symbol = 'BTCUSDT';
+  const side = args.side || 'long';
+  const amount = args.amount ? Number(args.amount) : 200;
+  const reduce = args.reduce ? Number(args.reduce) : 5;
+  const upReduce = args.up_reduce ? Number(args.up_reduce) : 5;
+  const confirm = args.confirm === true || args.confirm === 'true';
+  const monitorDuration = args.duration ? Number(args.duration) : 180; // 3 minutes
+  const monitorInterval = args.interval ? Number(args.interval) : 5; // 5 seconds
+
+  if (!confirm) {
+    console.log('⚠️  DRY-RUN MODE: Add --confirm to actually create position');
+    process.exit(0);
+  }
+
+  console.log('\n🚀 Creating Position and Monitoring SL Movement\n');
+  console.log(`Bot ID: ${botId}`);
+  console.log(`Symbol: ${symbol}`);
+  console.log(`Side: ${side}`);
+  console.log(`Amount: ${amount} USDT`);
+  console.log(`Reduce: ${reduce}`);
+  console.log(`Up Reduce: ${upReduce}`);
+  console.log(`Monitor Duration: ${monitorDuration} seconds`);
+  console.log(`Monitor Interval: ${monitorInterval} seconds\n`);
+
+  let tempStrategyId = null;
+  let positionId = null;
+
+  try {
+    // 1. Get bot
+    const bot = await Bot.findById(botId);
+    if (!bot) {
+      throw new Error(`Bot ${botId} not found`);
+    }
+
+    // 2. Create temp strategy
+    tempStrategyId = await createTempStrategy(botId, symbol, amount, reduce, upReduce);
+    console.log(`✅ Created temporary strategy id=${tempStrategyId}\n`);
+
+    // 3. Get strategy with bot info
+    const [strategyRows] = await pool.execute(
+      `SELECT * FROM strategies WHERE id = ?`,
+      [tempStrategyId]
+    );
+    const strategy = strategyRows[0];
+    strategy.bot = bot;
+
+    // 4. Initialize services
+    const exSvc = new ExchangeService(bot);
+    await exSvc.initialize(); // Initialize exchange service
+    const entryPrice = await exSvc.getTickerPrice(symbol);
+    console.log(`📊 Current price for ${symbol}: ${entryPrice}\n`);
+
+    // 5. Initialize Telegram and OrderService
+    const { TelegramService } = await import('../src/services/TelegramService.js');
+    const telegram = new TelegramService();
+    await telegram.initialize();
+    
+    // 6. Create position via OrderService
+    console.log('📝 Creating position via OrderService.executeSignal...\n');
+    const orderSvc = new OrderService(exSvc, telegram);
+    const signal = {
+      strategy,
+      side,
+      entryPrice,
+      amount
+    };
+
+    let res = null;
+    const maxRetries = 5;
+    for (let attempt = 1; attempt <= maxRetries; attempt++) {
+      res = await orderSvc.executeSignal(signal);
+      if (res && res.id) {
+        break;
+      }
+      if (attempt < maxRetries) {
+        console.log(`[Retry ${attempt}/${maxRetries}] Waiting 2s...\n`);
+        await sleep(2000);
+      }
+    }
+
+    if (!res || !res.id) {
+      throw new Error(`Failed to create position after ${maxRetries} attempts`);
+    }
+
+    positionId = res.id;
+    console.log(`✅ Position created: id=${positionId}, entry_price=${res.entry_price}\n`);
+
+    // 7. Initialize PositionMonitor
+    const posMonitor = new PositionMonitor();
+    posMonitor.telegramService = telegram;
+    await posMonitor.addBot(bot);
+    
+    // 8. Place TP/SL orders
+    console.log('📌 Placing TP/SL orders...\n');
+    let pos = await Position.findById(positionId);
+    await posMonitor.placeTpSlOrders(pos);
+    await sleep(3000);
+
+    // 9. Reload position
+    pos = await Position.findById(positionId);
+    console.log(`✅ TP/SL placed: TP=${pos.tp_order_id}, SL=${pos.sl_order_id}\n`);
+
+    // 10. Start monitoring
+    console.log('='.repeat(100));
+    console.log('🔍 Starting SL Movement Monitor\n');
+    console.log('='.repeat(100) + '\n');
+
+    const startTime = Date.now();
+    const endTime = startTime + (monitorDuration * 1000);
+    let iteration = 0;
+    let prevSL = Number(pos.stop_loss_price || 0);
+    let prevMinutes = Number(pos.minutes_elapsed || 0);
+    let prevTP = Number(pos.take_profit_price || 0);
+
+    while (Date.now() < endTime) {
+      iteration++;
+      const elapsed = Math.floor((Date.now() - startTime) / 1000);
+      const remaining = monitorDuration - elapsed;
+
+      // Reload position
+      const fresh = await Position.findById(positionId);
+      if (!fresh || fresh.status !== 'open') {
+        console.log(`\n⚠️  Position ${positionId} is no longer open (status: ${fresh?.status}). Stopping monitor.`);
+        break;
+      }
+
+      // Get current price
+      let currentPrice;
+      try {
+        currentPrice = await exSvc.getTickerPrice(fresh.symbol);
+      } catch (e) {
+        currentPrice = null;
+      }
+
+      const currentSL = Number(fresh.stop_loss_price || 0);
+      const currentTP = Number(fresh.take_profit_price || 0);
+      const currentMinutes = Number(fresh.minutes_elapsed || 0);
+
+      // Calculate time since position opened
+      const openedAt = fresh.opened_at ? new Date(fresh.opened_at).getTime() : null;
+      const actualMinutesElapsed = openedAt ? Math.floor((Date.now() - openedAt) / (60 * 1000)) : null;
+
+      // Check for changes
+      const slChanged = Math.abs(currentSL - prevSL) > 0.01;
+      const tpChanged = Math.abs(currentTP - prevTP) > 0.01;
+      const minutesChanged = currentMinutes !== prevMinutes;
+
+      // Display status
+      const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
+      console.log(`\n[${timestamp}] Iteration ${iteration} | Elapsed: ${elapsed}s | Remaining: ${remaining}s`);
+      console.log(`  Current Price: ${currentPrice ? currentPrice.toFixed(2) : 'N/A'}`);
+      console.log(`  Stop Loss: ${currentSL.toFixed(2)} ${slChanged ? `(CHANGED from ${prevSL.toFixed(2)})` : ''}`);
+      console.log(`  Take Profit: ${currentTP.toFixed(2)} ${tpChanged ? `(CHANGED from ${prevTP.toFixed(2)})` : ''}`);
+      console.log(`  Minutes Elapsed (DB): ${currentMinutes} ${minutesChanged ? `(CHANGED from ${prevMinutes})` : ''}`);
+      console.log(`  Minutes Elapsed (Actual): ${actualMinutesElapsed !== null ? actualMinutesElapsed : 'N/A'}`);
+
+      if (slChanged || tpChanged || minutesChanged) {
+        console.log(`  ✅ CHANGES DETECTED!`);
+        if (slChanged) {
+          const slDelta = currentSL - prevSL;
+          const slDeltaPercent = ((slDelta / prevSL) * 100).toFixed(4);
+          console.log(`     SL moved: ${prevSL.toFixed(2)} → ${currentSL.toFixed(2)} (Δ${slDelta > 0 ? '+' : ''}${slDelta.toFixed(2)}, ${slDeltaPercent > 0 ? '+' : ''}${slDeltaPercent}%)`);
+        }
+        if (tpChanged) {
+          const tpDelta = currentTP - prevTP;
+          const tpDeltaPercent = ((tpDelta / prevTP) * 100).toFixed(4);
+          console.log(`     TP moved: ${prevTP.toFixed(2)} → ${currentTP.toFixed(2)} (Δ${tpDelta > 0 ? '+' : ''}${tpDelta.toFixed(2)}, ${tpDeltaPercent > 0 ? '+' : ''}${tpDeltaPercent}%)`);
+        }
+        if (minutesChanged) {
+          console.log(`     Minutes elapsed: ${prevMinutes} → ${currentMinutes}`);
+        }
+      } else {
+        console.log(`  ⏳ No changes detected`);
+      }
+
+      // Update previous values
+      prevSL = currentSL;
+      prevTP = currentTP;
+      prevMinutes = currentMinutes;
+
+      // Call monitorPosition to trigger updates
+      try {
+        await posMonitor.monitorPosition(fresh);
+      } catch (e) {
+        logger.error(`Error in monitorPosition: ${e?.message || e}`);
+      }
+
+      // Wait before next iteration
+      if (remaining > 0) {
+        await sleep(monitorInterval * 1000);
+      }
+    }
+
+    console.log('\n' + '='.repeat(100));
+    console.log('\n✅ Monitoring completed!');
+    console.log(`   Total iterations: ${iteration}`);
+    console.log(`   Total duration: ${Math.floor((Date.now() - startTime) / 1000)} seconds`);
+
+    // Final state
+    const final = await Position.findById(positionId);
+    if (final) {
+      console.log('\n📊 Final Position State:');
+      console.log(`   Stop Loss Price: ${final.stop_loss_price || 'N/A'}`);
+      console.log(`   Take Profit Price: ${final.take_profit_price || 'N/A'}`);
+      console.log(`   Minutes Elapsed: ${final.minutes_elapsed || 0}`);
+      console.log(`   Status: ${final.status}`);
+    }
+
+  } catch (error) {
+    logger.error('Failed:', error);
+    console.error('\n❌ Error:', error.message);
+    process.exit(1);
+  } finally {
+    if (tempStrategyId) {
+      try {
+        await pool.execute(`DELETE FROM strategies WHERE id = ?`, [tempStrategyId]);
+        console.log(`\n🧹 Cleaned up temporary strategy id=${tempStrategyId}`);
+      } catch (e) {
+        // Ignore
+      }
+    }
+    // Don't close pool - let it stay open for monitoring
+    console.log('\n✨ Done.');
+  }
+}
+
+main().catch(err => {
+  console.error('Fatal error:', err);
+  process.exit(1);
+});
+
Index: scripts/test_tp_sl_flow_binance.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/test_tp_sl_flow_binance.js b/scripts/test_tp_sl_flow_binance.js
new file mode 100644
--- /dev/null	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
+++ b/scripts/test_tp_sl_flow_binance.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -0,0 +1,383 @@
+#!/usr/bin/env node
+/**
+ * Script: test_tp_sl_flow_binance.js
+ *
+ * Mục tiêu:
+ * - Cô lập và verify luồng: OPEN POSITION -> PLACE TP/SL -> TRAILING (reduce / up_reduce)
+ * - Chạy trên Binance Futures TESTNET với bot_id = 3
+ * - Mở 1 lệnh SHORT BTCUSDT với size nhỏ, dùng MARKET để khớp ngay
+ * - Ngay sau khi position mở:
+ *   + Đảm bảo Position được tạo trong DB
+ *   + Gọi PositionMonitor.placeTpSlOrders() để đặt TP/SL trên sàn
+ *   + Gọi PositionMonitor.monitorPosition() vài lần để quan sát log đuổi SL/TP
+ *
+ * Usage:
+ *  node scripts/test_tp_sl_flow_binance.js --bot_id 3 --symbol BTCUSDT --side short --amount 30 --confirm
+ */
+
+import dotenv from 'dotenv';
+import pool from '../src/config/database.js';
+import logger from '../src/utils/logger.js';
+import { ExchangeService } from '../src/services/ExchangeService.js';
+import { OrderService } from '../src/services/OrderService.js';
+import { PositionMonitor } from '../src/jobs/PositionMonitor.js';
+import { TelegramService } from '../src/services/TelegramService.js';
+import { Position } from '../src/models/Position.js';
+import { Bot } from '../src/models/Bot.js';
+
+dotenv.config();
+
+function parseArgs(argv) {
+  const out = {};
+  for (let i = 0; i < argv.length; i++) {
+    const a = argv[i];
+    if (a.startsWith('--')) {
+      const key = a.replace(/^--/, '');
+      const next = argv[i + 1];
+      if (!next || next.startsWith('--')) {
+        out[key] = true;
+      } else {
+        out[key] = next;
+        i++;
+      }
+    }
+  }
+  return out;
+}
+
+const args = parseArgs(process.argv.slice(2));
+
+async function sleep(ms) {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+
+function normalizeSymbol(sym) {
+  const s = String(sym || '').toUpperCase().replace(/[\/:_]/g, '');
+  if (s === 'BTC') return 'BTCUSDT';
+  return s;
+}
+
+async function getBot(botId) {
+  const bot = await Bot.findById(botId);
+  if (!bot) throw new Error(`Bot id=${botId} not found`);
+  if ((bot.exchange || '').toLowerCase() !== 'binance') {
+    throw new Error(`Bot id=${botId} must be Binance, got exchange=${bot.exchange}`);
+  }
+  if (!bot.binance_testnet) {
+    logger.warn(`[TP/SL Test] Bot ${botId} không bật testnet (binance_testnet=false). ĐẢM BẢO đây là tài khoản test nếu vẫn tiếp tục.`);
+  }
+  if (!bot.is_active) {
+    throw new Error(`Bot id=${botId} is not active (is_active != 1)`);
+  }
+  return bot;
+}
+
+async function createTempStrategy(botId, symbol, amountUSDT, reduce, upReduce) {
+  // Chiến lược tạm:
+  // - interval: 15m
+  // - oc: 2%
+  // - take_profit: 20%
+  // - reduce / up_reduce: cấu hình từ CLI để test trailing
+  
+  // Cleanup any existing temporary strategy for this bot/symbol to avoid duplicates
+  try {
+    await pool.execute(
+      `DELETE FROM strategies 
+       WHERE bot_id = ? AND symbol = ? AND \`interval\` = '15m' AND oc = 2 AND take_profit = 20 
+       AND is_active = 0`,
+      [botId, symbol]
+    );
+  } catch (e) {
+    // Ignore cleanup errors
+  }
+  
+  const [res] = await pool.execute(
+    `INSERT INTO strategies (bot_id, symbol, \`interval\`, amount, oc, take_profit, reduce, extend, up_reduce, \`ignore\`, is_active, created_at, updated_at)
+     VALUES (?, ?, '15m', ?, 2, 20, ?, 0, ?, 0, 0, NOW(), NOW())`,
+    [botId, symbol, amountUSDT, reduce, upReduce]
+  );
+  if (!res.insertId) {
+    throw new Error('Failed to create temporary strategy for TP/SL test');
+  }
+  const id = res.insertId;
+  logger.info(`[TP/SL Test] Created temporary strategy id=${id} bot_id=${botId} symbol=${symbol}`);
+  return id;
+}
+
+async function deleteTempStrategy(strategyId) {
+  if (!strategyId) return;
+  try {
+    const [res] = await pool.execute(
+      `DELETE FROM strategies WHERE id = ?`,
+      [strategyId]
+    );
+    if (res.affectedRows > 0) {
+      logger.info(`[TP/SL Test] Cleaned up temporary strategy id=${strategyId}`);
+    }
+  } catch (e) {
+    logger.warn(`[TP/SL Test] Failed to clean up temp strategy id=${strategyId}: ${e?.message || e}`);
+  }
+}
+
+async function main() {
+  const botId = Number(args.bot_id || 3);
+  const symbol = normalizeSymbol(args.symbol || 'BTCUSDT');
+  const side = String(args.side || 'short').toLowerCase();
+  const amount = Number(args.amount || 30); // USDT
+  const reduce = Number(args.reduce ?? 5);
+  const upReduce = Number(args.up_reduce ?? 5);
+  const confirm = !!args.confirm;
+
+  if (!['long', 'short'].includes(side)) {
+    throw new Error(`Invalid --side=${side}, must be long|short`);
+  }
+  if (!Number.isFinite(amount) || amount <= 0) {
+    throw new Error(`Invalid --amount=${amount}`);
+  }
+  if (!Number.isFinite(reduce) || reduce < 0) {
+    throw new Error(`Invalid --reduce=${reduce}`);
+  }
+  if (!Number.isFinite(upReduce) || upReduce < 0) {
+    throw new Error(`Invalid --up_reduce=${upReduce}`);
+  }
+
+  let tempStrategyId;
+
+  try {
+    const bot = await getBot(botId);
+    console.log(`[INFO] Using bot id=${bot.id}: name=${bot.bot_name || 'N/A'}, exchange=${bot.exchange}, testnet=${bot.binance_testnet}`);
+
+    const telegram = new TelegramService();
+    await telegram.initialize();
+
+    const exSvc = new ExchangeService(bot);
+    await exSvc.initialize();
+    const orderSvc = new OrderService(exSvc, telegram);
+    const posMonitor = new PositionMonitor();
+    // Inject telegram + add only this bot
+    posMonitor.telegramService = telegram;
+    await posMonitor.addBot(bot);
+
+    tempStrategyId = await createTempStrategy(bot.id, symbol, amount, reduce, upReduce);
+
+    // Mock strategy object như StrategyService trả về
+    const strategy = {
+      id: tempStrategyId,
+      bot_id: bot.id,
+      symbol,
+      amount,
+      oc: 2,
+      take_profit: 20,
+      reduce,
+      up_reduce: upReduce,
+      bot
+    };
+
+    const current = await exSvc.getTickerPrice(symbol);
+    if (!Number.isFinite(Number(current)) || Number(current) <= 0) {
+      throw new Error(`Cannot fetch current price for ${symbol}: ${current}`);
+    }
+    console.log(`[INFO] Current price for ${symbol}: ${current}`);
+
+    const entryPrice = Number(current); // dùng MARKET, nên entry ~ current
+
+    console.log('\n=== TP/SL Flow Test (Binance testnet) ===');
+    console.log(`Bot ID      : ${bot.id}`);
+    console.log(`Symbol      : ${symbol}`);
+    console.log(`Side        : ${side.toUpperCase()}`);
+    console.log(`Amount(USDT): ${amount}`);
+    console.log(`Entry Price : ${entryPrice}`);
+    console.log(`Mode        : ${confirm ? 'CONFIRMED - WILL PLACE REAL MARKET ORDER' : 'DRY-RUN'}`);
+    console.log(`Strategy    : { oc=2, take_profit=20, reduce=${reduce}, up_reduce=${upReduce} }`);
+
+    if (!confirm) {
+      console.log('\nPass --confirm để thực sự gửi lệnh MARKET lên Binance testnet.');
+      return;
+    }
+
+    // 1) Snapshot BEFORE
+    const beforePositions = await Position.findOpenBySymbol(symbol);
+    console.log('\n[0] Open positions BEFORE:', beforePositions.filter(p => Number(p.bot_id) === bot.id));
+
+    // 2) Place ENTRY MARKET via OrderService.executeSignal
+    console.log('\n[1] Placing ENTRY MARKET order via OrderService.executeSignal...');
+    const signal = {
+      strategy,
+      side,
+      entryPrice,
+      amount
+    };
+    
+    // Retry logic for concurrency lock timeout
+    let res = null;
+    const maxRetries = 5;
+    const retryDelay = 2000; // 2 seconds
+    
+    for (let attempt = 1; attempt <= maxRetries; attempt++) {
+      res = await orderSvc.executeSignal(signal);
+      if (res && res.id) {
+        break; // Success
+      }
+      
+      if (attempt < maxRetries) {
+        console.log(`[Retry ${attempt}/${maxRetries}] Concurrency lock timeout or limit reached, waiting ${retryDelay}ms before retry...`);
+        console.log(`[Info] This may be due to many open positions or concurrent requests. Consider closing some positions if this persists.`);
+        await sleep(retryDelay);
+      } else {
+        // Get concurrency status for better error message
+        const { concurrencyManager } = await import('../src/services/ConcurrencyManager.js');
+        const status = await concurrencyManager.getStatus(bot.id);
+        throw new Error(
+          `OrderService.executeSignal failed after ${maxRetries} attempts.\n` +
+          `Last result: ${JSON.stringify(res)}\n` +
+          `Concurrency status: ${status.currentCount}/${status.maxConcurrent} positions open.\n` +
+          `This may be due to:\n` +
+          `  1. Concurrency lock timeout (too many concurrent requests)\n` +
+          `  2. Max concurrent trades limit reached\n` +
+          `  3. Too many open positions (${status.currentCount}/${status.maxConcurrent})\n` +
+          `Solution: Close some positions or wait a few seconds and retry.`
+        );
+      }
+    }
+    
+    if (!res || !res.id) {
+      throw new Error(`OrderService.executeSignal did not return a Position: ${JSON.stringify(res)}`);
+    }
+    console.log(`[OK] Position opened: id=${res.id}, order_id=${res.order_id}, side=${res.side}, entry_price=${res.entry_price}`);
+
+    // 3) Reload position from DB
+    let pos = await Position.findById(res.id);
+    console.log('\n[2] Position from DB right after open:', {
+      id: pos.id,
+      bot_id: pos.bot_id,
+      symbol: pos.symbol,
+      side: pos.side,
+      entry_price: pos.entry_price,
+      take_profit_price: pos.take_profit_price,
+      stop_loss_price: pos.stop_loss_price,
+      tp_order_id: pos.tp_order_id,
+      sl_order_id: pos.sl_order_id
+    });
+
+    // 4) Force TP/SL placement via PositionMonitor.placeTpSlOrders
+    console.log('\n[3] Forcing TP/SL placement via PositionMonitor.placeTpSlOrders() ...');
+    await posMonitor.placeTpSlOrders(pos);
+    await sleep(3000);
+
+    // 5) Reload position to inspect TP/SL orders
+    pos = await Position.findById(res.id);
+    console.log('\n[4] Position AFTER TP/SL placement attempt:', {
+      id: pos.id,
+      bot_id: pos.bot_id,
+      symbol: pos.symbol,
+      side: pos.side,
+      entry_price: pos.entry_price,
+      take_profit_price: pos.take_profit_price,
+      stop_loss_price: pos.stop_loss_price,
+      tp_order_id: pos.tp_order_id,
+      sl_order_id: pos.sl_order_id
+    });
+
+    if (!pos.tp_order_id || !pos.sl_order_id) {
+      console.log('\n[WARN] TP hoặc SL vẫn chưa được gắn vào position trong DB. Kiểm tra log [Place TP/SL] và Binance open orders để debug thêm.');
+    } else {
+      console.log('\n[OK] TP/SL đã được tạo và gắn vào position trong DB.');
+    }
+
+    // 6) Chạy vài vòng monitorPosition để xem log đuổi giá (reduce / up_reduce)
+    console.log('\n[5] Running monitorPosition() vài lần để quan sát log SL Update / TP Chase ...');
+    for (let i = 1; i <= 5; i++) {
+      console.log(`\n[Monitor Iteration ${i}]`);
+      const fresh = await Position.findById(res.id);
+      if (!fresh || fresh.status !== 'open') {
+        console.log(`[INFO] Position ${res.id} không còn open (status=${fresh?.status}). Dừng monitor.`);
+        break;
+      }
+      
+      // Log position state BEFORE monitoring
+      const openedAt = fresh.opened_at ? new Date(fresh.opened_at).getTime() : Date.now();
+      const now = Date.now();
+      const actualMinutesElapsed = Math.floor((now - openedAt) / (60 * 1000));
+      const currentPrice = await exSvc.getTickerPrice(fresh.symbol);
+      
+      console.log(`[BEFORE Monitor] Position State:`);
+      console.log(`  - ID: ${fresh.id}`);
+      console.log(`  - Status: ${fresh.status}`);
+      console.log(`  - Side: ${fresh.side}`);
+      console.log(`  - Entry Price: ${fresh.entry_price}`);
+      console.log(`  - Current Market Price: ${currentPrice}`);
+      console.log(`  - Take Profit Price: ${fresh.take_profit_price}`);
+      console.log(`  - Stop Loss Price: ${fresh.stop_loss_price}`);
+      console.log(`  - TP Order ID: ${fresh.tp_order_id || 'N/A'}`);
+      console.log(`  - SL Order ID: ${fresh.sl_order_id || 'N/A'}`);
+      console.log(`  - Minutes Elapsed (DB): ${fresh.minutes_elapsed || 0}`);
+      console.log(`  - Minutes Elapsed (Actual): ${actualMinutesElapsed}`);
+      console.log(`  - Reduce: ${fresh.reduce || 'N/A'}`);
+      console.log(`  - Up Reduce: ${fresh.up_reduce || 'N/A'}`);
+      console.log(`  - Opened At: ${fresh.opened_at}`);
+      console.log(`  - Time Since Open: ${Math.floor((now - openedAt) / 1000)} seconds`);
+      
+      // Call monitorPosition
+      console.log(`\n[Calling monitorPosition...]`);
+      try {
+        await posMonitor.monitorPosition(fresh);
+      } catch (error) {
+        console.error(`[ERROR] monitorPosition failed:`, error?.message || error);
+        console.error(error?.stack);
+      }
+      
+      // Wait and reload position
+      await sleep(2000);
+      const afterFresh = await Position.findById(res.id);
+      
+      // Log position state AFTER monitoring
+      console.log(`\n[AFTER Monitor] Position State:`);
+      console.log(`  - Status: ${afterFresh?.status || 'N/A'}`);
+      console.log(`  - Take Profit Price: ${afterFresh?.take_profit_price || 'N/A'} (was: ${fresh.take_profit_price})`);
+      console.log(`  - Stop Loss Price: ${afterFresh?.stop_loss_price || 'N/A'} (was: ${fresh.stop_loss_price})`);
+      console.log(`  - TP Order ID: ${afterFresh?.tp_order_id || 'N/A'} (was: ${fresh.tp_order_id || 'N/A'})`);
+      console.log(`  - SL Order ID: ${afterFresh?.sl_order_id || 'N/A'} (was: ${fresh.sl_order_id || 'N/A'})`);
+      console.log(`  - Minutes Elapsed (DB): ${afterFresh?.minutes_elapsed || 0} (was: ${fresh.minutes_elapsed || 0})`);
+      console.log(`  - PnL: ${afterFresh?.pnl || 'N/A'}`);
+      
+      // Check if TP/SL changed
+      const tpChanged = afterFresh?.take_profit_price !== fresh.take_profit_price;
+      const slChanged = afterFresh?.stop_loss_price !== fresh.stop_loss_price;
+      const tpOrderChanged = afterFresh?.tp_order_id !== fresh.tp_order_id;
+      const slOrderChanged = afterFresh?.sl_order_id !== fresh.sl_order_id;
+      
+      if (tpChanged || slChanged || tpOrderChanged || slOrderChanged) {
+        console.log(`\n[CHANGES DETECTED]`);
+        if (tpChanged) console.log(`  ✅ TP Price changed: ${fresh.take_profit_price} → ${afterFresh?.take_profit_price}`);
+        if (slChanged) console.log(`  ✅ SL Price changed: ${fresh.stop_loss_price} → ${afterFresh?.stop_loss_price}`);
+        if (tpOrderChanged) console.log(`  ✅ TP Order changed: ${fresh.tp_order_id || 'N/A'} → ${afterFresh?.tp_order_id || 'N/A'}`);
+        if (slOrderChanged) console.log(`  ✅ SL Order changed: ${fresh.sl_order_id || 'N/A'} → ${afterFresh?.sl_order_id || 'N/A'}`);
+      } else {
+        console.log(`\n[NO CHANGES] TP/SL prices and orders remain unchanged.`);
+        console.log(`  - Actual minutes elapsed: ${actualMinutesElapsed}`);
+        console.log(`  - DB minutes elapsed: ${afterFresh?.minutes_elapsed || 0}`);
+        if (actualMinutesElapsed > (afterFresh?.minutes_elapsed || 0)) {
+          console.log(`  ⚠️  WARNING: Actual time (${actualMinutesElapsed} min) > DB time (${afterFresh?.minutes_elapsed || 0} min) - SL/TP should have moved!`);
+        }
+      }
+      
+      await sleep(3000); // Wait 3 seconds between iterations
+    }
+
+    console.log('\n=== TP/SL Flow Test FINISHED ===');
+  } finally {
+    if (tempStrategyId) {
+      await deleteTempStrategy(tempStrategyId);
+    }
+    await pool.end();
+  }
+}
+
+main().catch(err => {
+  console.error('Fatal error in test_tp_sl_flow_binance:', err?.message || err);
+  console.error(err?.stack || '');
+  pool.end();
+  process.exit(1);
+});
+
+
Index: src/consumers/WebSocketOCConsumer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/consumers/WebSocketOCConsumer.js b/src/consumers/WebSocketOCConsumer.js
--- a/src/consumers/WebSocketOCConsumer.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/consumers/WebSocketOCConsumer.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -237,7 +237,10 @@
 
       // Calculate TP and SL (based on side)
       const tpPrice = calculateTakeProfit(entryPrice, Math.abs(oc), strategy.take_profit || 55, side);
-      const slPrice = calculateInitialStopLoss(tpPrice, Math.abs(oc), strategy.reduce || 10, side);
+      // Only compute SL when strategy.stoploss > 0. No fallback to reduce/up_reduce
+      const rawStoploss = strategy.stoploss !== undefined ? Number(strategy.stoploss) : NaN;
+      const isStoplossValid = Number.isFinite(rawStoploss) && rawStoploss > 0;
+      const slPrice = isStoplossValid ? calculateInitialStopLoss(entryPrice, rawStoploss, side) : null;
 
       // Create signal object - OrderService.executeSignal expects strategy object
       const signal = {
Index: src/jobs/EntryOrderMonitor.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jobs/EntryOrderMonitor.js b/src/jobs/EntryOrderMonitor.js
--- a/src/jobs/EntryOrderMonitor.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/jobs/EntryOrderMonitor.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -182,7 +182,10 @@
       const { calculateTakeProfit, calculateInitialStopLoss } = await import('../utils/calculator.js');
       const side = entry.side;
       const tpPrice = calculateTakeProfit(effectiveEntryPrice, strategy.oc, strategy.take_profit, side);
-      const slPrice = calculateInitialStopLoss(tpPrice, strategy.oc, strategy.reduce, side);
+      // Only set SL if strategy.stoploss > 0. No fallback to reduce/up_reduce
+      const rawStoploss = strategy.stoploss !== undefined ? Number(strategy.stoploss) : NaN;
+      const isStoplossValid = Number.isFinite(rawStoploss) && rawStoploss > 0;
+      const slPrice = isStoplossValid ? calculateInitialStopLoss(effectiveEntryPrice, rawStoploss, side) : null;
 
       const position = await Position.create({
         strategy_id: entry.strategy_id,
Index: src/jobs/PositionMonitor.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jobs/PositionMonitor.js b/src/jobs/PositionMonitor.js
--- a/src/jobs/PositionMonitor.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/jobs/PositionMonitor.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -128,7 +128,10 @@
       // Recalculate TP/SL based on the real entry price
       const { calculateTakeProfit, calculateInitialStopLoss } = await import('../utils/calculator.js');
       const tpPrice = calculateTakeProfit(fillPrice, position.oc, position.take_profit, position.side);
-      const slPrice = calculateInitialStopLoss(tpPrice, position.oc, position.reduce, position.side);
+      // Only set SL if strategy.stoploss > 0. No fallback to reduce/up_reduce
+      const rawStoploss = position.stoploss !== undefined ? Number(position.stoploss) : NaN;
+      const isStoplossValid = Number.isFinite(rawStoploss) && rawStoploss > 0;
+      const slPrice = isStoplossValid ? calculateInitialStopLoss(fillPrice, rawStoploss, position.side) : null;
 
       // Get the exact quantity of the position
       const quantity = await exchangeService.getClosableQuantity(position.symbol, position.side);
@@ -143,16 +146,49 @@
           const tpRes = await exchangeService.createTakeProfitLimit(position.symbol, position.side, tpPrice, quantity);
           const tpOrderId = tpRes?.orderId ? String(tpRes.orderId) : null;
           if (tpOrderId) {
+            // Store initial TP price for trailing calculation
+            // We'll use a comment field or calculate from strategy each time
+            // For now, initial TP = current TP (first time)
             await Position.update(position.id, { tp_order_id: tpOrderId, take_profit_price: tpPrice });
-            logger.info(`[Place TP/SL] ✅ Placed TP order ${tpOrderId} for position ${position.id} @ ${tpPrice}`);
+            logger.info(`[Place TP/SL] ✅ Placed TP order ${tpOrderId} for position ${position.id} @ ${tpPrice} (initial TP)`);
           }
         } catch (e) {
           logger.error(`[Place TP/SL] ❌ Failed to create TP order for position ${position.id}:`, e?.message || e);
         }
       }
 
-      // Place SL order
-      if (!position.sl_order_id) {
+      // Place SL order (only if slPrice is valid, i.e., stoploss > 0)
+      if (!position.sl_order_id && slPrice !== null && Number.isFinite(slPrice) && slPrice > 0) {
+        // Safety check: If SL is invalid (SL <= entry for SHORT or SL >= entry for LONG), force close position immediately
+        const entryPrice = Number(fillPrice);
+        const slPriceNum = Number(slPrice);
+        if (Number.isFinite(entryPrice) && entryPrice > 0 && Number.isFinite(slPriceNum) && slPriceNum > 0) {
+          const isInvalidSL = (position.side === 'short' && slPriceNum <= entryPrice) || 
+                             (position.side === 'long' && slPriceNum >= entryPrice);
+          
+          if (isInvalidSL) {
+            logger.warn(`[Place TP/SL] Invalid SL detected for position ${position.id}: SL=${slPriceNum}, Entry=${entryPrice}, Side=${position.side}. Force closing position immediately to minimize risk.`);
+            
+            // Cancel TP order if any
+            if (position.tp_order_id) {
+              try {
+                await exchangeService.cancelOrder(position.tp_order_id, position.symbol);
+                logger.info(`[Place TP/SL] Cancelled TP order ${position.tp_order_id} for position ${position.id}`);
+              } catch (e) {
+                logger.warn(`[Place TP/SL] Failed to cancel TP order ${position.tp_order_id}: ${e?.message || e}`);
+              }
+            }
+            
+            // Force close position immediately with market order
+            const { PositionService } = await import('../services/PositionService.js');
+            const positionService = new PositionService(exchangeService);
+            const currentPrice = await exchangeService.getTickerPrice(position.symbol);
+            const pnl = positionService.calculatePnL(position, currentPrice);
+            await positionService.closePosition(position, currentPrice, pnl, 'sl_invalid');
+            return; // Exit early, position is closed
+          }
+        }
+        
         try {
           const slRes = await exchangeService.createStopLossLimit(position.symbol, position.side, slPrice, quantity);
           const slOrderId = slRes?.orderId ? String(slRes.orderId) : null;
@@ -163,6 +199,8 @@
         } catch (e) {
           logger.error(`[Place TP/SL] ❌ Failed to create SL order for position ${position.id}:`, e?.message || e);
         }
+      } else if (slPrice === null || slPrice <= 0) {
+        logger.info(`[Place TP/SL] Skipping SL order placement for position ${position.id} (stoploss <= 0 or not set)`);
       }
     } catch (error) {
       logger.error(`[Place TP/SL] Error processing TP/SL for position ${position.id}:`, error?.message || error, error?.stack);
Index: src/models/Position.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/models/Position.js b/src/models/Position.js
--- a/src/models/Position.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/models/Position.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -11,7 +11,7 @@
    */
   static async findAll(filters = {}) {
     let query = `SELECT p.*, s.symbol, s.\`interval\`, s.oc, s.take_profit, 
-                        s.reduce, s.up_reduce, s.extend, p.bot_id, b.bot_name, b.exchange
+                        s.reduce, s.up_reduce, s.extend, s.stoploss, p.bot_id, b.bot_name, b.exchange
                  FROM positions p
                  JOIN strategies s ON p.strategy_id = s.id
                  JOIN bots b ON p.bot_id = b.id`;
@@ -52,7 +52,7 @@
   static async findById(id) {
     const [rows] = await pool.execute(
       `SELECT p.*, s.symbol, s.interval, s.oc, s.take_profit,
-              s.reduce, s.up_reduce, s.extend, s.bot_id,
+              s.reduce, s.up_reduce, s.extend, s.stoploss, s.bot_id,
               b.bot_name, b.exchange, b.telegram_chat_id, b.telegram_alert_channel_id
        FROM positions p
        JOIN strategies s ON p.strategy_id = s.id
@@ -70,7 +70,7 @@
    */
   static async findOpen(strategyId = null) {
     let query = `SELECT p.*, s.symbol, s.\`interval\`, s.oc, s.take_profit,
-                        s.reduce, s.up_reduce, s.bot_id, b.bot_name, b.exchange
+                        s.reduce, s.up_reduce, s.stoploss, s.bot_id, b.bot_name, b.exchange
                  FROM positions p
                  JOIN strategies s ON p.strategy_id = s.id
                  JOIN bots b ON p.bot_id = b.id
@@ -95,7 +95,7 @@
    */
   static async findOpenBySymbol(symbol) {
     const [rows] = await pool.execute(
-      `SELECT p.*, s.oc, s.take_profit, s.reduce, s.up_reduce
+      `SELECT p.*, s.oc, s.take_profit, s.reduce, s.up_reduce, s.stoploss
        FROM positions p
        JOIN strategies s ON p.strategy_id = s.id
        WHERE p.symbol = ? AND p.status = 'open'`,
@@ -135,14 +135,18 @@
       } catch (_) {}
     }
 
+    // Set opened_at explicitly using JavaScript Date to ensure correct timezone
+    const openedAt = new Date();
+    
     const [result] = await pool.execute(
       `INSERT INTO positions (
         strategy_id, bot_id, order_id, symbol, side, entry_price, amount,
-        take_profit_price, stop_loss_price, current_reduce, tp_order_id, sl_order_id
-      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
+        take_profit_price, stop_loss_price, current_reduce, tp_order_id, sl_order_id, opened_at
+      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
       [
         safe(strategy_id), safe(bot_id), safe(order_id), safe(symbol), safe(side), safe(entry_price), safe(amount),
-        safe(take_profit_price), safe(stop_loss_price), safe(current_reduce), safe(tp_order_id), safe(sl_order_id)
+        safe(take_profit_price), safe(stop_loss_price), safe(current_reduce), safe(tp_order_id), safe(sl_order_id),
+        openedAt
       ]
     );
 
Index: src/services/BinanceDirectClient.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/services/BinanceDirectClient.js b/src/services/BinanceDirectClient.js
--- a/src/services/BinanceDirectClient.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/services/BinanceDirectClient.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -1274,6 +1274,20 @@
       params.quantity = formattedQuantity; // Pass as string
     }
     
+    // Safety check to prevent -2021 "Order would immediately trigger"
+    const currentPrice = await this.getPrice(normalizedSymbol);
+    if (currentPrice) {
+      const stopNum = parseFloat(stopPrice);
+      if (side === 'long' && stopNum >= currentPrice) {
+        logger.warn(`[SL-SKIP] SL price ${stopNum} for LONG is at or above current price ${currentPrice}. Skipping order to prevent immediate trigger.`);
+        return null;
+      }
+      if (side === 'short' && stopNum <= currentPrice) {
+        logger.warn(`[SL-SKIP] SL price ${stopNum} for SHORT is at or below current price ${currentPrice}. Skipping order to prevent immediate trigger.`);
+        return null;
+      }
+    }
+    
     logger.info(`Creating SL limit order: ${orderSide} ${normalizedSymbol} @ stopPrice=${stopPrice}, limitPrice=${limitPrice}${dualSide ? ` (${positionSide})` : ''}`);
     
     try {
Index: src/services/ExchangeService.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/services/ExchangeService.js b/src/services/ExchangeService.js
--- a/src/services/ExchangeService.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/services/ExchangeService.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -794,6 +794,34 @@
     return '0.01';
   }
 
+  /**
+   * Get average fill price for a given order (used for accurate entry/TP/SL)
+   * Currently implemented only for Binance via direct client.
+   * @param {string} symbol - Symbol in internal format (e.g. BTCUSDT)
+   * @param {string|number} orderId - Exchange orderId
+   * @returns {Promise<number|null>}
+   */
+  async getOrderAverageFillPrice(symbol, orderId) {
+    try {
+      if (this.bot.exchange === 'binance' && this.binanceDirectClient) {
+        const normalizedSymbol = this.binanceDirectClient.normalizeSymbol(symbol);
+        const price = await this.binanceDirectClient.getOrderAverageFillPrice(
+          normalizedSymbol,
+          orderId
+        );
+        const num = Number(price);
+        return Number.isFinite(num) && num > 0 ? num : null;
+      }
+      // Other exchanges: not implemented yet, let callers fallback
+      return null;
+    } catch (e) {
+      logger.warn(
+        `[ExchangeService] getOrderAverageFillPrice failed for ${symbol} order=${orderId}: ${e?.message || e}`
+      );
+      return null;
+    }
+  }
+
   async createEntryTriggerOrder(symbol, side, entryPrice, quantity) {
     if (this.bot.exchange === 'binance' && this.binanceDirectClient) {
       const normalizedSymbol = this.binanceDirectClient.normalizeSymbol(symbol);
Index: src/services/OrderService.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/services/OrderService.js b/src/services/OrderService.js
--- a/src/services/OrderService.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/services/OrderService.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -187,24 +187,27 @@
       // Calculate temporary TP/SL prices based on the effective entry price
       const { calculateTakeProfit, calculateInitialStopLoss } = await import('../utils/calculator.js');
       const tempTpPrice = calculateTakeProfit(effectiveEntryPrice, strategy.oc, strategy.take_profit, side);
-      const tempSlPrice = calculateInitialStopLoss(tempTpPrice, strategy.oc, strategy.reduce, side);
+      // Only compute SL when strategy.stoploss > 0. No fallback to reduce/up_reduce
+      const rawStoploss = strategy.stoploss !== undefined ? Number(strategy.stoploss) : NaN;
+      const hasValidStoploss = Number.isFinite(rawStoploss) && rawStoploss > 0;
+      const tempSlPrice = hasValidStoploss ? calculateInitialStopLoss(effectiveEntryPrice, rawStoploss, side) : null;
 
       let position = null;
 
       if (hasImmediateExposure || orderType === 'market') {
         // MARKET or immediately-filled LIMIT: create Position right away
         position = await Position.create({
-          strategy_id: strategy.id,
-          bot_id: strategy.bot_id,
-          order_id: order.id,
-          symbol: strategy.symbol,
-          side: side,
+        strategy_id: strategy.id,
+        bot_id: strategy.bot_id,
+        order_id: order.id,
+        symbol: strategy.symbol,
+        side: side,
           entry_price: effectiveEntryPrice,
-          amount: amount,
-          take_profit_price: tempTpPrice, // Use temporary TP price
-          stop_loss_price: tempSlPrice, // Use temporary SL price
-          current_reduce: strategy.reduce
-        });
+        amount: amount,
+        take_profit_price: tempTpPrice, // Use temporary TP price
+        stop_loss_price: tempSlPrice, // Use temporary SL price
+        current_reduce: strategy.reduce
+      });
       } else {
         // Pending LIMIT (no confirmed fill yet): track in entry_orders table
         try {
@@ -225,37 +228,37 @@
       }
 
       if (position) {
-        logger.info(`Position opened:`, {
-          positionId: position.id,
-          symbol: strategy.symbol,
-          side,
-          entryPrice: position.entry_price,
-          tpPrice,
-          slPrice
-        });
+      logger.info(`Position opened:`, {
+        positionId: position.id,
+        symbol: strategy.symbol,
+        side,
+        entryPrice: position.entry_price,
+        tpPrice,
+        slPrice
+      });
 
-        // Send Telegram notification to bot chat
-        await this.telegramService.sendOrderNotification(position, strategy);
+      // Send Telegram notification to bot chat
+      await this.telegramService.sendOrderNotification(position, strategy);
 
-        // Send entry trade alert to central channel
-        try {
-          logger.info(`[OrderService] Preparing to send entry trade alert for position ${position.id}`);
-          // Ensure bot info present
-          if (!strategy.bot && strategy.bot_id) {
-            const { Bot } = await import('../models/Bot.js');
-            strategy.bot = await Bot.findById(strategy.bot_id);
-            logger.info(`[OrderService] Fetched bot info: ${strategy.bot?.bot_name || 'N/A'}`);
-          }
-          logger.info(`[OrderService] Calling sendEntryTradeAlert for position ${position.id}, strategy ${strategy.id}`);
-          await this.telegramService.sendEntryTradeAlert(position, strategy, signal.oc);
-          logger.info(`[OrderService] ✅ Entry trade alert sent successfully for position ${position.id}`);
-        } catch (e) {
-          logger.error(`[OrderService] Failed to send entry trade channel alert for position ${position.id}:`, e);
-          logger.error(`[OrderService] Error stack:`, e?.stack);
-        }
+      // Send entry trade alert to central channel
+      try {
+        logger.info(`[OrderService] Preparing to send entry trade alert for position ${position.id}`);
+        // Ensure bot info present
+        if (!strategy.bot && strategy.bot_id) {
+          const { Bot } = await import('../models/Bot.js');
+          strategy.bot = await Bot.findById(strategy.bot_id);
+          logger.info(`[OrderService] Fetched bot info: ${strategy.bot?.bot_name || 'N/A'}`);
+        }
+        logger.info(`[OrderService] Calling sendEntryTradeAlert for position ${position.id}, strategy ${strategy.id}`);
+        await this.telegramService.sendEntryTradeAlert(position, strategy, signal.oc);
+        logger.info(`[OrderService] ✅ Entry trade alert sent successfully for position ${position.id}`);
+      } catch (e) {
+        logger.error(`[OrderService] Failed to send entry trade channel alert for position ${position.id}:`, e);
+        logger.error(`[OrderService] Error stack:`, e?.stack);
+      }
 
-        // TP/SL creation is now handled by PositionMonitor after entry confirmation.
-        logger.info(`Entry order placed for position ${position.id}. TP/SL will be placed by PositionMonitor.`);
+      // TP/SL creation is now handled by PositionMonitor after entry confirmation.
+      logger.info(`Entry order placed for position ${position.id}. TP/SL will be placed by PositionMonitor.`);
 
         // Central log: success
         await this.sendCentralLog(`Order Success | bot=${strategy?.bot_id} strat=${strategy?.id} ${strategy?.symbol} ${String(side).toUpperCase()} orderId=${order?.id} posId=${position?.id} type=${orderType} entry=${position.entry_price} tp=${tempTpPrice} sl=${tempSlPrice}`);
@@ -274,7 +277,7 @@
       // - Position object when exposure is confirmed
       // - Lightweight descriptor when only entry_orders record exists
       if (position) {
-        return position;
+      return position;
       }
       return {
         pending: true,
Index: src/services/PositionService.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/services/PositionService.js b/src/services/PositionService.js
--- a/src/services/PositionService.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/services/PositionService.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -1,5 +1,5 @@
 import { Position } from '../models/Position.js';
-import { calculatePnL, calculateDynamicStopLoss, calculateTakeProfit, calculateInitialStopLoss } from '../utils/calculator.js';
+import { calculatePnL, calculatePnLPercent, calculateDynamicStopLoss, calculateTakeProfit, calculateInitialStopLoss, calculateNextTrailingStop, calculateNextTrailingTakeProfit } from '../utils/calculator.js';
 import { exchangeInfoService } from './ExchangeInfoService.js';
 import { configService } from './ConfigService.js';
 import logger from '../utils/logger.js';
@@ -69,131 +69,185 @@
         return await this.closePosition(position, currentPrice, pnl, 'sl_hit');
       }
 
-      // Compute dynamic stop loss (converging from TP)
+      // NEW LOGIC: Trailing Take Profit (NOT Stop Loss)
+      // Calculate minutes_elapsed from actual time elapsed
+      // This ensures TP trails exactly once per minute based on real time
+      let openedAt;
+      let useTimeBasedCalculation = true;
+      
+      if (position.opened_at) {
+        openedAt = new Date(position.opened_at).getTime();
+        if (isNaN(openedAt)) {
+          logger.warn(`[TP Trail] pos=${position.id} Invalid opened_at format: ${position.opened_at}, falling back to increment-based calculation`);
+          useTimeBasedCalculation = false;
+        }
+      } else {
+        logger.warn(`[TP Trail] pos=${position.id} opened_at is null/undefined, falling back to increment-based calculation`);
+        useTimeBasedCalculation = false;
+      }
+      
       const prevMinutes = Number(position.minutes_elapsed || 0);
-      const minutesElapsed = prevMinutes + 1;
-      const oc = Number(position.oc || 0);
-      let updatedSL = this.calculateUpdatedStopLoss(position);
-      const currentReduce = Number(position.reduce || 0) + (minutesElapsed * Number(position.up_reduce || 0));
-      const clampedReduce = Math.min(Math.max(currentReduce, 0), 999999.99);
-      logger.info(`[SL Update] pos=${position.id} ${position.symbol} side=${position.side} oc=${oc} reduce=${position.reduce} up_reduce=${position.up_reduce} minutes ${prevMinutes} -> ${minutesElapsed} sl_old=${position.stop_loss_price} sl_new=${updatedSL} currentReduce=${clampedReduce.toFixed(2)}`);
-
-      // Cancel/replace SL pending order on exchange if moved enough ticks
-      try {
-          const thresholdTicks = Number(configService.getNumber('SL_UPDATE_THRESHOLD_TICKS', 2));
-          // Try to get tick size from cache first
-          let tickSizeStr = exchangeInfoService.getTickSize(position.symbol);
-          if (!tickSizeStr) {
-            // Fallback to REST API if cache miss
-            tickSizeStr = await this.exchangeService.getTickSize(position.symbol);
-          }
-          const tick = parseFloat(tickSizeStr || '0') || 0;
-          const prevSL = Number(position.stop_loss_price || 0);
-          const newSL = Number(updatedSL || 0);
-          if (tick > 0 && newSL > 0 && prevSL > 0) {
-            const moved = Math.abs(newSL - prevSL);
-            if (moved >= thresholdTicks * tick) {
-              // Cancel old SL if exists
-              if (position.sl_order_id) {
-                try {
-                  await this.exchangeService.cancelOrder(position.sl_order_id, position.symbol);
-                  logger.info(`[SL Replace] Cancelled old SL order ${position.sl_order_id} for position ${position.id}`);
-                } catch (e) {
-                  logger.warn(`[SL Replace] Failed to cancel old SL order ${position.sl_order_id}: ${e?.message || e}`);
-                }
-              }
-              // Determine current closable qty
-              const qty = await this.exchangeService.getClosableQuantity(position.symbol, position.side);
-              if (qty > 0) {
-                const slRes = await this.exchangeService.createStopLossLimit(position.symbol, position.side, newSL, qty);
-                const newSlOrderId = slRes?.orderId ? String(slRes.orderId) : null;
-                if (newSlOrderId) {
-                  await Position.update(position.id, { sl_order_id: newSlOrderId });
-                  logger.info(`[SL Replace] Placed new SL ${newSlOrderId} @ ${newSL} for position ${position.id}`);
-                }
-              } else {
-                logger.warn(`[SL Replace] Skip placing new SL, qty=${qty}`);
-              }
-            }
-          }
-        } catch (e) {
-          logger.warn(`[SL Replace] Error processing SL update: ${e?.message || e}`);
-        }
+      let actualMinutesElapsed;
+      
+      if (useTimeBasedCalculation) {
+        const now = Date.now();
+        actualMinutesElapsed = Math.floor((now - openedAt) / (60 * 1000)); // Minutes since position opened
+        logger.info(`[TP Trail] pos=${position.id} Timing check: opened_at=${position.opened_at} openedAt=${openedAt} now=${now} actualMinutesElapsed=${actualMinutesElapsed} prevMinutes=${prevMinutes} timeDiff=${now - openedAt}ms (${Math.floor((now - openedAt) / 1000)}s)`);
+        
+        // Only update TP if actual minutes have increased (ensures exactly once per minute)
+        if (actualMinutesElapsed <= prevMinutes) {
+          logger.info(`[TP Trail] pos=${position.id} actualMinutes=${actualMinutesElapsed} <= prevMinutes=${prevMinutes}, skipping TP trail (not yet time for next step)`);
+          // Still update PnL and return without changing TP
+          const updatePayload = {
+            pnl: pnl
+          };
+          const updated = await Position.update(position.id, updatePayload);
+          return updated;
+        }
+        
+        // Calculate how many minutes to process (max 1 minute per call to ensure smooth movement)
+        const minutesToProcess = Math.min(actualMinutesElapsed - prevMinutes, 1); // Only process 1 minute at a time
+        actualMinutesElapsed = prevMinutes + minutesToProcess; // Use incremental value
+        
+        logger.info(`[TP Trail] pos=${position.id} Proceeding with TP trail: actualMinutes=${Math.floor((now - openedAt) / (60 * 1000))} > prevMinutes=${prevMinutes}, processing ${minutesToProcess} minute(s), targetMinutes=${actualMinutesElapsed}`);
+      } else {
+        // Fallback: increment-based calculation
+        actualMinutesElapsed = prevMinutes + 1;
+        logger.info(`[TP Trail] pos=${position.id} Using increment-based calculation: prevMinutes=${prevMinutes} -> actualMinutesElapsed=${actualMinutesElapsed}`);
+      }
+      
+      // Only set initial SL if it doesn't exist (SL should NOT be moved after initial setup)
+      const prevSL = Number(position.stop_loss_price || 0);
+      if (prevSL <= 0) {
+        const updatedSL = this.calculateUpdatedStopLoss(position);
+        if (updatedSL !== null && Number.isFinite(updatedSL) && updatedSL > 0) {
+          await Position.update(position.id, { stop_loss_price: updatedSL });
+          logger.info(`[TP Trail] Set initial SL for position ${position.id}: ${updatedSL}`);
+        }
+      }
 
-        // Cancel/replace TP theo chiến thuật Reduce / Up Reduce (đuổi TP về phía giá market)
+        // NEW LOGIC: Trailing Take Profit from initial TP towards entry
         try {
           const prevTP = Number(position.take_profit_price || 0);
+          const entryPrice = Number(position.entry_price || 0);
           const marketPrice = Number(currentPrice);
           const reduce = Number(position.reduce || 0);
           const upReduce = Number(position.up_reduce || 0);
+          const minutesElapsed = actualMinutesElapsed; // Use calculated minutes
 
-          // Nếu không có TP hiện tại hoặc giá market không hợp lệ thì bỏ qua
-          if (!Number.isFinite(prevTP) || prevTP <= 0 || !Number.isFinite(marketPrice) || marketPrice <= 0) {
-            logger.debug(`[TP Replace] Skip TP chase for position ${position.id} - invalid prevTP=${prevTP} or marketPrice=${marketPrice}`);
+          logger.debug(`[TP Trail] Starting TP trail check for position ${position.id}: prevTP=${prevTP} entryPrice=${entryPrice} marketPrice=${marketPrice} reduce=${reduce} upReduce=${upReduce} minutesElapsed=${minutesElapsed}`);
+
+          // Need initial TP to calculate trailing
+          if (!Number.isFinite(prevTP) || prevTP <= 0) {
+            logger.warn(`[TP Trail] Skip TP trail for position ${position.id} - no initial TP (prevTP=${prevTP})`);
+          } else if (!Number.isFinite(entryPrice) || entryPrice <= 0) {
+            logger.warn(`[TP Trail] Skip TP trail for position ${position.id} - invalid entry price (${entryPrice})`);
           } else if (reduce <= 0 && upReduce <= 0) {
-            // Chế độ tĩnh: TP không đuổi giá, giữ TP theo cấu hình ban đầu (fallback cũ)
-            const desiredTPStatic = calculateTakeProfit(
-            Number(position.entry_price),
-            Number(position.oc || 0),
-            Number(position.take_profit || 0),
-            position.side
-          );
-            await this._maybeReplaceTpOrder(position, prevTP, desiredTPStatic);
+            logger.debug(`[TP Trail] Static mode: reduce=${reduce} upReduce=${upReduce}, TP will not trail`);
+            // Static mode: TP stays at initial value
           } else {
-            // Chế độ đuổi TP: P_n = P_{n-1} + (P_market - P_{n-1}) * Rate
-            // Rate được suy ra từ reduce + up_reduce * minutesElapsed
-            const rawRate = reduce + minutesElapsed * upReduce;
-            const rate = Math.min(Math.max(rawRate / 100, 0), 1); // 10 -> 10%, clamp 0..100%
-
-            let targetTp = prevTP + (marketPrice - prevTP) * rate;
-
-            // Offset an toàn quanh market để tránh khớp ngay tại giá market
-            const offsetPct = Number(configService.getNumber('TP_CHASE_OFFSET_PCT', 0.1)); // %
-            const offset = marketPrice * (offsetPct / 100);
-
-            if (position.side === 'short') {
-              // TP phải luôn <= market - offset
-              const maxTp = marketPrice - offset;
-              targetTp = Math.min(targetTp, maxTp);
+            // Trailing mode: TP moves from initial TP towards entry
+            // Calculate initial TP from strategy (same as when position was opened)
+            const entryPriceForTP = Number(position.entry_price || 0);
+            const oc = Number(position.oc || 0);
+            const takeProfit = Number(position.take_profit || 0);
+            let initialTP = prevTP; // Fallback to current TP
+            
+            if (entryPriceForTP > 0 && takeProfit > 0) {
+              // Recalculate initial TP from strategy (same calculation as placeTpSlOrders)
+              initialTP = calculateTakeProfit(entryPriceForTP, oc, takeProfit, position.side);
+              logger.debug(`[TP Trail] Calculated initial TP from strategy: ${initialTP.toFixed(2)} (entry=${entryPriceForTP}, take_profit=${takeProfit})`);
             } else {
-              // LONG: TP phải luôn >= market + offset
-              const minTp = marketPrice + offset;
-              targetTp = Math.max(targetTp, minTp);
+              // If we can't calculate, use current TP as initial (first time)
+              initialTP = prevTP;
+              logger.debug(`[TP Trail] Using current TP as initial: ${initialTP.toFixed(2)}`);
             }
-
-            // Giới hạn bước nhảy mỗi lần (Max Step) để tránh nhảy quá xa
-            const maxStepPct = Number(configService.getNumber('TP_CHASE_MAX_STEP_PCT', 0.5)); // %
-            const maxStep = marketPrice * (maxStepPct / 100);
-            const delta = targetTp - prevTP;
-            const absDelta = Math.abs(delta);
-            let newTP = prevTP;
-            if (absDelta > 0) {
-              const step = Math.sign(delta) * Math.min(absDelta, maxStep);
-              newTP = prevTP + step;
-            }
-
+            
+            const trailingPercent = position.side === 'long' ? upReduce : reduce;
+            
+            // Calculate next TP: trails from initial TP towards entry
+            const newTP = calculateNextTrailingTakeProfit(prevTP, entryPrice, initialTP, trailingPercent, position.side);
+            
             logger.info(
-              `[TP Chase] pos=${position.id} ${position.symbol} side=${position.side} ` +
-              `prevTP=${prevTP} market=${marketPrice} rawRate=${rawRate.toFixed(2)}% ` +
-              `targetTp=${targetTp} newTP=${newTP}`
+              `[TP Trail] pos=${position.id} ${position.symbol} side=${position.side} ` +
+              `prevTP=${prevTP.toFixed(2)} newTP=${newTP.toFixed(2)} entry=${entryPrice.toFixed(2)} ` +
+              `initialTP=${initialTP.toFixed(2)} trailing=${trailingPercent} minutesElapsed=${minutesElapsed}`
             );
 
-            await this._maybeReplaceTpOrder(position, prevTP, newTP);
+            // Check if TP has crossed entry (Case 2)
+            const hasCrossedEntry = (position.side === 'long' && newTP <= entryPrice) || 
+                                   (position.side === 'short' && newTP >= entryPrice);
+            
+            if (hasCrossedEntry) {
+              // Case 2: TP has crossed entry - check if too close to market
+              const distanceFromMarket = Math.abs(newTP - marketPrice);
+              const distancePercent = (distanceFromMarket / marketPrice) * 100;
+              
+              logger.info(`[TP Trail] TP ${newTP.toFixed(2)} crossed entry ${entryPrice.toFixed(2)} for ${position.side} position ${position.id}. Distance from market: ${distancePercent.toFixed(3)}%`);
+              
+              if (distancePercent <= 0.5) {
+                // Too close to market - close position immediately
+                logger.warn(`[TP Trail] TP too close to market (${distancePercent.toFixed(3)}% <= 0.5%). Closing position ${position.id} by MARKET order.`);
+                try {
+                  const qty = await this.exchangeService.getClosableQuantity(position.symbol, position.side);
+                  if (qty > 0) {
+                    const qtyToClose = await this.exchangeService.getClosableQuantity(position.symbol, position.side);
+                    if (qtyToClose > 0) {
+                      await this.exchangeService.closePosition(position.symbol, position.side, qtyToClose);
+                    }
+                    await this.closePosition(position, marketPrice, pnl, 'trailing_exit');
+                    logger.info(`[TP Trail] Closed position ${position.id} by MARKET order (TP too close to market)`);
+                    return await Position.findById(position.id);
+                  }
+                } catch (e) {
+                  logger.error(`[TP Trail] Failed to close position by MARKET: ${e?.message || e}`);
+                }
+              } else {
+                // Convert TP order to STOP_LIMIT order
+                await this._convertTpToStopLimit(position, newTP);
+              }
+            } else {
+              // Case 1: TP still in profit zone - continue using TAKE_PROFIT_LIMIT
+              await this._maybeReplaceTpOrder(position, prevTP, newTP);
+              
+              // Update take_profit_price and minutes_elapsed in DB
+              await Position.update(position.id, { 
+                take_profit_price: newTP,
+                minutes_elapsed: actualMinutesElapsed
+              });
+              logger.debug(`[TP Trail] Updated position ${position.id}: take_profit_price=${newTP.toFixed(2)}, minutes_elapsed=${actualMinutesElapsed}`);
+            }
           }
         } catch (e) {
-          logger.warn(`[TP Replace] Error processing TP update: ${e?.message || e}`);
+          logger.warn(`[TP Trail] Error processing TP trail: ${e?.message || e}`);
         }
+        
+        // Update minutes_elapsed even if TP trail was skipped
+        await Position.update(position.id, { minutes_elapsed: actualMinutesElapsed });
 
       // Calculate current_reduce and clamp to prevent overflow (computed above)
-      // Re-use clampedReduce computed from reduce + minutesElapsed * up_reduce
+      // Re-use clampedReduce computed from reduce + actualMinutesElapsed * up_reduce
 
       // Update position
-      const updated = await Position.update(position.id, {
+      // Calculate current_reduce for tracking (not used for trailing anymore, but kept for compatibility)
+      const currentReduce = Number(position.reduce || 0) + (actualMinutesElapsed * Number(position.up_reduce || 0));
+      const clampedReduce = Math.min(Math.max(currentReduce, 0), 999999.99);
+      
+      const updatePayload = {
         pnl: pnl,
-        stop_loss_price: updatedSL,
         current_reduce: clampedReduce,
-        minutes_elapsed: minutesElapsed
-      });
+        minutes_elapsed: actualMinutesElapsed
+      };
+      
+      // Only update stop_loss_price if SL was calculated (initial SL setup)
+      if (updatedSL !== null && Number.isFinite(updatedSL) && updatedSL > 0) {
+        const prevSL = Number(position.stop_loss_price || 0);
+        // Only update if SL changed (initial setup) or doesn't exist
+        if (prevSL <= 0 || Math.abs(updatedSL - prevSL) > 0.0001) {
+          updatePayload.stop_loss_price = updatedSL;
+        }
+      }
+      const updated = await Position.update(position.id, updatePayload);
 
       return updated;
     } catch (error) {
@@ -207,6 +261,14 @@
    */
   async _maybeReplaceTpOrder(position, prevTP, desiredTP) {
     try {
+          const entryPrice = Number(position.entry_price || 0);
+          const newTP = Number(desiredTP || 0);
+          
+          logger.debug(`[TP Replace] _maybeReplaceTpOrder called: pos=${position.id} prevTP=${prevTP.toFixed(2)} desiredTP=${newTP.toFixed(2)} entryPrice=${entryPrice.toFixed(2)} side=${position.side}`);
+          
+          // Note: TP→SL conversion is now handled in the main TP trail logic
+          // This function only handles TP order replacement when TP is still in profit zone
+          
           const thresholdTicksTP = Number(configService.getNumber('TP_UPDATE_THRESHOLD_TICKS', configService.getNumber('SL_UPDATE_THRESHOLD_TICKS', 2)));
           // Try to get tick size from cache first
           let tickSizeStrTP = exchangeInfoService.getTickSize(position.symbol);
@@ -215,10 +277,16 @@
             tickSizeStrTP = await this.exchangeService.getTickSize(position.symbol);
           }
           const tickTP = parseFloat(tickSizeStrTP || '0') || 0;
-          const newTP = Number(desiredTP || 0);
+          
+          logger.debug(`[TP Replace] Threshold check: tickTP=${tickTP} thresholdTicksTP=${thresholdTicksTP} prevTP=${prevTP.toFixed(2)} newTP=${newTP.toFixed(2)}`);
+          
           if (tickTP > 0 && newTP > 0 && prevTP > 0) {
             const movedTP = Math.abs(newTP - prevTP);
-            if (movedTP >= thresholdTicksTP * tickTP) {
+            const effectiveThreshold = thresholdTicksTP * tickTP;
+            logger.debug(`[TP Replace] Movement check: movedTP=${movedTP.toFixed(4)} effectiveThreshold=${effectiveThreshold.toFixed(4)}`);
+            
+            if (movedTP >= effectiveThreshold) {
+              logger.debug(`[TP Replace] Movement threshold met, proceeding with TP order replacement`);
               if (position.tp_order_id) {
                 try {
                   await this.exchangeService.cancelOrder(position.tp_order_id, position.symbol);
@@ -229,19 +297,34 @@
               }
               const qty = await this.exchangeService.getClosableQuantity(position.symbol, position.side);
               if (qty > 0) {
-                const tpRes = await this.exchangeService.createTakeProfitLimit(position.symbol, position.side, newTP, qty);
-                const newTpOrderId = tpRes?.orderId ? String(tpRes.orderId) : null;
-                const updatePayload = { take_profit_price: newTP };
-                if (newTpOrderId) updatePayload.tp_order_id = newTpOrderId;
-                await Position.update(position.id, updatePayload);
-                logger.info(`[TP Replace] Placed new TP ${newTpOrderId || ''} @ ${newTP} for position ${position.id}`);
+                // Only create TP order if TP is on the correct side of Entry
+                const entryPrice = Number(position.entry_price || 0);
+                const isValidTP = Number.isFinite(entryPrice) && entryPrice > 0 &&
+                  ((position.side === 'short' && newTP <= entryPrice) || 
+                   (position.side === 'long' && newTP >= entryPrice));
+                
+                if (isValidTP) {
+                  const tpRes = await this.exchangeService.createTakeProfitLimit(position.symbol, position.side, newTP, qty);
+                  const newTpOrderId = tpRes?.orderId ? String(tpRes.orderId) : null;
+                  const updatePayload = { take_profit_price: newTP };
+                  if (newTpOrderId) updatePayload.tp_order_id = newTpOrderId;
+                  await Position.update(position.id, updatePayload);
+                  logger.info(`[TP Replace] Placed new TP ${newTpOrderId || ''} @ ${newTP} for position ${position.id}`);
+                } else {
+                  logger.debug(`[TP Replace] TP ${newTP} is on wrong side of Entry ${entryPrice}, skipping TP order creation (will be handled by SL conversion)`);
+                }
               } else {
                 logger.warn(`[TP Replace] Skip placing new TP, qty=${qty}`);
               }
+            } else {
+              logger.debug(`[TP Replace] Movement ${movedTP.toFixed(4)} < threshold ${effectiveThreshold.toFixed(4)}, skipping TP order replacement`);
             }
+          } else {
+            logger.warn(`[TP Replace] Invalid tickTP (${tickTP}) or TP values (prevTP=${prevTP} newTP=${newTP}), skipping TP order replacement`);
           }
         } catch (e) {
       logger.warn(`[TP Replace] Error processing TP replace: ${e?.message || e}`);
+      logger.error(`[TP Replace] Error stack:`, e?.stack);
     }
   }
 
@@ -276,32 +359,52 @@
   }
 
   /**
-   * Calculate updated stop loss based on elapsed time (trailing stop from current price)
+   * Calculate updated stop loss based on previous SL and up_reduce (trailing stop)
+   * This function calculates the next SL step by moving from the previous SL towards entry price
    * @param {Object} position - Position object
-   * @param {number} currentPrice - Current market price
    * @returns {number} Updated stop loss price
    */
   calculateUpdatedStopLoss(position) {
-    const oc = Number(position.oc || 0);
-    const tp = Number(position.take_profit_price || 0);
-    if (!Number.isFinite(tp) || tp <= 0 || !Number.isFinite(oc)) {
-      return position.stop_loss_price; // cannot compute without valid TP/OC
-    }
-    const nextSL = calculateDynamicStopLoss(
-      tp,
-      oc,
-      Number(position.reduce || 0),
-      Number(position.up_reduce || 0),
-      Number(position.minutes_elapsed || 0) + 1,
-      position.side
-    );
-    // Monotonic constraint: move only in favorable direction
     const prevSL = Number(position.stop_loss_price || 0);
-    if (Number.isFinite(prevSL) && prevSL > 0) {
-      if (position.side === 'long' && nextSL < prevSL) return prevSL;
-      if (position.side === 'short' && nextSL > prevSL) return prevSL;
+    const entry = Number(position.entry_price || 0);
+    
+    logger.debug(`[calculateUpdatedStopLoss] pos=${position.id} prevSL=${prevSL} entry=${entry} side=${position.side}`);
+    
+    // NEW LOGIC: SL should NOT be moved after initial setup
+    // Only calculate initial SL if it doesn't exist yet
+    if (!Number.isFinite(prevSL) || prevSL <= 0) {
+      // Get stoploss from strategy (position may have it from JOIN)
+      const stoploss = position.stoploss !== undefined ? position.stoploss : null;
+      
+      if (!Number.isFinite(entry) || entry <= 0) {
+        logger.warn(`[calculateUpdatedStopLoss] Invalid entry price: ${entry}, cannot calculate initial SL`);
+        return null;
+      }
+      
+      // Check if stoploss is valid (not NULL, not undefined, > 0)
+      // Only set SL when strategy.stoploss > 0, no fallback
+      const isStoplossValid = stoploss !== null && stoploss !== undefined && Number.isFinite(Number(stoploss)) && Number(stoploss) > 0;
+      
+      if (!isStoplossValid) {
+        logger.debug(`[calculateUpdatedStopLoss] stoploss is NULL or invalid (${stoploss}), skipping SL setup for position ${position.id}`);
+        return null; // No stoploss - only set SL when strategy.stoploss > 0
+      }
+      
+      // Only set SL when strategy.stoploss > 0
+      const initialSL = calculateInitialStopLoss(entry, stoploss, position.side);
+      
+      if (initialSL === null || initialSL <= 0) {
+        logger.warn(`[calculateUpdatedStopLoss] Calculated SL is invalid: ${initialSL} for position ${position.id} (entry=${entry}, stoploss=${stoploss})`);
+        return null;
+      }
+      
+      logger.info(`[calculateUpdatedStopLoss] Calculated initial SL: ${initialSL} for position ${position.id} (entry=${entry}, stoploss=${stoploss})`);
+      return initialSL;
     }
-    return nextSL;
+    
+    // SL already exists - DO NOT MOVE IT (keep it static)
+    logger.debug(`[calculateUpdatedStopLoss] SL already exists (${prevSL}), keeping it static (no trailing)`);
+    return prevSL;
   }
 
   /**
@@ -312,8 +415,25 @@
    * @param {string} reason - Close reason
    * @returns {Promise<Object>} Closed position
    */
+  async sendTelegramCloseNotification(closedPosition) {
+    try {
+      if (!this.telegramService?.sendCloseSummaryAlert) {
+        logger.warn(`[Notification] TelegramService not available, skipping close summary alert for position ${closedPosition.id}`);
+        return;
+      }
+      logger.info(`[Notification] Preparing to send close summary for position ${closedPosition.id}`);
+      const stats = await Position.getBotStats(closedPosition.bot_id);
+      logger.debug(`[Notification] Fetched bot stats for bot ${closedPosition.bot_id}:`, stats);
+      await this.telegramService.sendCloseSummaryAlert(closedPosition, stats);
+      logger.info(`[Notification] ✅ Successfully sent close summary alert for position ${closedPosition.id}`);
+    } catch (inner) {
+      logger.error(`[Notification] ❌ Failed to send close summary alert for position ${closedPosition.id}:`, inner?.message || inner, inner?.stack);
+    }
+  }
+
   async closePosition(position, currentPrice, pnl, reason) {
     try {
+
       // Pre-check: ensure there is exposure to close on exchange
       try {
         const qty = await this.exchangeService.getClosableQuantity(position.symbol, position.side);
@@ -363,26 +483,15 @@
         closePrice: safeClosePrice
       });
 
-      // Send Telegram close summary to central channel with stats
+      // After position is confirmed closed, cancel any remaining TP/SL orders
       try {
-        logger.info(`[Notification] Preparing to send close summary for position ${closed.id}`);
-        const stats = await Position.getBotStats(closed.bot_id);
-        logger.debug(`[Notification] Fetched bot stats for bot ${closed.bot_id}:`, stats);
-
-        if (this.telegramService?.sendCloseSummaryAlert) {
-          logger.info(`[Notification] Using existing TelegramService to send close summary for position ${closed.id}`);
-          await this.telegramService.sendCloseSummaryAlert(closed, stats);
-        } else {
-          logger.warn(`[Notification] No existing TelegramService found, creating temporary instance.`);
-          const { TelegramService } = await import('./TelegramService.js');
-          const tmpTele = new TelegramService();
-          await tmpTele.initialize();
-          await tmpTele.sendCloseSummaryAlert(closed, stats);
-        }
-        logger.info(`[Notification] ✅ Successfully sent close summary alert for position ${closed.id}`);
-      } catch (inner) {
-        logger.error(`[Notification] ❌ Failed to send close summary alert for position ${closed.id}:`, inner?.message || inner, inner?.stack);
+        logger.info(`[Close Position] Cleaning up any remaining open orders for symbol ${position.symbol}`);
+        await this.exchangeService.cancelAllOpenOrders(position.symbol);
+      } catch (e) {
+        logger.warn(`[Close Position] Failed to clean up open orders for ${position.symbol} after closing: ${e?.message || e}`);
       }
+
+      await this.sendTelegramCloseNotification(closed);
 
       return closed;
     } catch (error) {
@@ -391,6 +500,49 @@
     }
   }
 
+  /**
+   * Convert TP order to STOP_LIMIT order when TP crosses entry
+   * @param {Object} position - Position object
+   * @param {number} newTP - New TP price (which has crossed entry)
+   */
+  async _convertTpToStopLimit(position, newTP) {
+    try {
+      logger.info(`[TP->SL Convert] Converting TP to STOP_LIMIT for position ${position.id} at price ${newTP.toFixed(2)}`);
+      
+      // Cancel existing TP order
+      if (position.tp_order_id) {
+        try {
+          await this.exchangeService.cancelOrder(position.tp_order_id, position.symbol);
+          logger.info(`[TP->SL Convert] Cancelled TP order ${position.tp_order_id} for position ${position.id}`);
+        } catch (e) {
+          logger.warn(`[TP->SL Convert] Failed to cancel TP order ${position.tp_order_id}: ${e?.message || e}`);
+        }
+      }
+      
+      // Create STOP_LIMIT order at the new TP price
+      const qty = await this.exchangeService.getClosableQuantity(position.symbol, position.side);
+      if (qty > 0) {
+        const slRes = await this.exchangeService.createStopLossLimit(position.symbol, position.side, newTP, qty);
+        const newSlOrderId = slRes?.orderId ? String(slRes.orderId) : null;
+        if (newSlOrderId) {
+          // Update position: clear TP order, set SL order, update TP price (for tracking)
+          await Position.update(position.id, { 
+            tp_order_id: null, 
+            sl_order_id: newSlOrderId,
+            take_profit_price: newTP // Keep TP price for reference
+          });
+          logger.info(`[TP->SL Convert] Created STOP_LIMIT order ${newSlOrderId} @ ${newTP.toFixed(2)} for position ${position.id}`);
+        } else {
+          logger.warn(`[TP->SL Convert] Failed to create STOP_LIMIT order for position ${position.id}`);
+        }
+      } else {
+        logger.warn(`[TP->SL Convert] Skip creating STOP_LIMIT, qty=${qty}`);
+      }
+    } catch (e) {
+      logger.error(`[TP->SL Convert] Error converting TP to STOP_LIMIT: ${e?.message || e}`);
+    }
+  }
+
   /**
    * Check if position order should be cancelled (candle ended without fill)
    * @param {Object} position - Position object
Index: src/services/StrategyService.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/services/StrategyService.js b/src/services/StrategyService.js
--- a/src/services/StrategyService.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/services/StrategyService.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -199,7 +199,10 @@
 
       // Calculate TP and SL
       const tpPrice = calculateTakeProfit(entryPrice, Math.abs(oc), strategy.take_profit, side);
-      const slPrice = calculateInitialStopLoss(tpPrice, Math.abs(oc), strategy.reduce, side);
+      // Only set SL if strategy.stoploss > 0. No fallback to reduce/up_reduce
+      const rawStoploss = strategy.stoploss !== undefined ? Number(strategy.stoploss) : NaN;
+      const isStoplossValid = Number.isFinite(rawStoploss) && rawStoploss > 0;
+      const slPrice = isStoplossValid ? calculateInitialStopLoss(entryPrice, rawStoploss, side) : null;
 
       // Create signal
       return {
Index: src/utils/calculator.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/utils/calculator.js b/src/utils/calculator.js
--- a/src/utils/calculator.js	(revision 0eb9c00b95d4272577a09febe3dac2f9a84d4478)
+++ b/src/utils/calculator.js	(revision 8a108b4f0a5c1899d7365c5bb8b333ba23d0b702)
@@ -2,6 +2,52 @@
  * Trading calculation utilities
  */
 
+/**
+ * Calculate PnL (Profit and Loss)
+ * @param {number} entryPrice - Entry price
+ * @param {number} currentPrice - Current market price
+ * @param {number} amount - Position amount
+ * @param {'long'|'short'} side - Position side
+ * @returns {number} PnL value
+ */
+export function calculatePnL(entryPrice, currentPrice, amount, side) {
+  const entry = Number(entryPrice);
+  const current = Number(currentPrice);
+  const amt = Number(amount);
+  
+  if (!Number.isFinite(entry) || !Number.isFinite(current) || !Number.isFinite(amt)) {
+    return 0;
+  }
+  
+  if (side === 'long') {
+    return (current - entry) * amt;
+  } else {
+    return (entry - current) * amt;
+  }
+}
+
+/**
+ * Calculate PnL percentage
+ * @param {number} entryPrice - Entry price
+ * @param {number} currentPrice - Current market price
+ * @param {'long'|'short'} side - Position side
+ * @returns {number} PnL percentage
+ */
+export function calculatePnLPercent(entryPrice, currentPrice, side) {
+  const entry = Number(entryPrice);
+  const current = Number(currentPrice);
+  
+  if (!Number.isFinite(entry) || entry <= 0 || !Number.isFinite(current)) {
+    return 0;
+  }
+  
+  if (side === 'long') {
+    return ((current - entry) / entry) * 100;
+  } else {
+    return ((entry - current) / entry) * 100;
+  }
+}
+
 /**
  * Calculate OC (Open-Close) percentage
  * @param {number} open - Open price
@@ -78,107 +124,89 @@
 }
 
 /**
- * Calculate initial stop loss price
- * @param {number} tpPrice - Take profit price
- * @param {number} oc - OC percentage
- * @param {number} reduce - Initial reduce value
- * @param {'long'|'short'} side - Position side
- * @returns {number} Stop loss price
- */
-export function calculateInitialStopLoss(tpPrice, oc, reduce, side) {
-  const tp = Number(tpPrice);
-  const r = Number(reduce);
-  const ocn = Number(oc);
-  if (!Number.isFinite(tp) || !Number.isFinite(r) || !Number.isFinite(ocn)) return NaN;
-  const slOffset = (r * ocn) / 100;
-  if (side === 'long') {
-    return tp - slOffset;
-  } else {
-    return tp + slOffset;
-  }
-}
-
-/**
- * Calculate dynamic stop loss based on elapsed time (converging from TP)
- * @param {number} tpPrice - Take profit price
- * @param {number} oc - OC percentage
- * @param {number} reduce - Initial reduce value
- * @param {number} upReduce - Reduce acceleration per minute
- * @param {number} minutesElapsed - Minutes since position opened
+ * Calculate initial stop loss price based on entry price and stoploss percentage (similar to take_profit)
+ * @param {number} entryPrice - Entry price
+ * @param {number} stoploss - Stop loss percentage value (e.g., 50 = 5% if divided by 10, same format as take_profit)
  * @param {'long'|'short'} side - Position side
- * @returns {number} Updated stop loss price
+ * @returns {number|null} Stop loss price, or null if stoploss <= 0
  */
-export function calculateDynamicStopLoss(tpPrice, oc, reduce, upReduce, minutesElapsed, side) {
-  const tp = Number(tpPrice);
-  const baseReduce = Number(reduce);
-  const up = Number(upReduce);
-  const minutes = Number(minutesElapsed);
-  const ocN = Number(oc);
-
-  if (!Number.isFinite(tp) || !Number.isFinite(baseReduce) || !Number.isFinite(up) || !Number.isFinite(minutes) || !Number.isFinite(ocN)) {
-    return tp; // Fallback: giữ nguyên TP nếu input không hợp lệ
+export function calculateInitialStopLoss(entryPrice, stoploss, side) {
+  const entry = Number(entryPrice);
+  const sl = Number(stoploss);
+  
+  // If stoploss is not a valid number or <= 0, return null (no stoploss)
+  if (!Number.isFinite(entry) || entry <= 0 || !Number.isFinite(sl) || sl <= 0) {
+    return null;
   }
-
-  // Cách 2: Đuổi theo TP (trailing về phía TP theo thời gian)
-  // - Thay vì tăng khoảng cách như công thức cũ (reduce + minutes * up_reduce),
-  //   ta cho khoảng cách GIẢM dần theo thời gian:
-  //   effectiveReduce = max(reduce - minutes * up_reduce, 0)
-  //
-  // Điều này khiến stop loss "kéo" dần về TP (thu hẹp khoảng cách),
-  // trong khi PositionService vẫn giữ ràng buộc monotonic:
-  // - LONG  : chỉ cho SL tăng lên (gần giá hơn)
-  // - SHORT : chỉ cho SL giảm xuống (gần giá hơn)
-  const effectiveReduce = Math.max(baseReduce - minutes * up, 0);
-
-  // Giữ nguyên đơn vị cũ: slOffset = (effectiveReduce * oc) / 100
-  const slOffset = (effectiveReduce * ocN) / 100;
-
+  
+  // Calculate stoploss percentage (same format as take_profit: divide by 10)
+  // e.g., stoploss = 50 → actualSLPercent = 5%
+  const actualSLPercent = sl / 10;
+  
   if (side === 'long') {
-    return tp - slOffset;
+    // LONG: SL < Entry, so SL = Entry * (1 - stoploss%)
+    return entry * (1 - actualSLPercent / 100);
   } else {
-    return tp + slOffset;
+    // SHORT: SL > Entry, so SL = Entry * (1 + stoploss%)
+    return entry * (1 + actualSLPercent / 100);
   }
 }
 
 /**
- * Calculate PnL percentage
- * @param {number} entryPrice - Entry price
- * @param {number} currentPrice - Current price
+ * Calculate next trailing take profit price - moves from initial TP towards entry
+ * This is the NEW logic: TP trails from initial TP towards entry, NOT SL movement
+ * @param {number} prevTP - Previous take profit price
+ * @param {number} entryPrice - Entry price (target to trail towards)
+ * @param {number} initialTP - Initial take profit price (starting point)
+ * @param {number} reducePercent - Reduce percentage per minute (same format as take_profit: divide by 10)
  * @param {'long'|'short'} side - Position side
- * @returns {number} PnL percentage
+ * @returns {number} Next take profit price
  */
-export function calculatePnLPercent(entryPrice, currentPrice, side) {
-  const e = Number(entryPrice);
-  const c = Number(currentPrice);
+export function calculateNextTrailingTakeProfit(prevTP, entryPrice, initialTP, reducePercent, side) {
+  const prev = Number(prevTP);
+  const entry = Number(entryPrice);
+  const initial = Number(initialTP);
+  const reduce = Number(reducePercent);
+  
+  if (!Number.isFinite(prev) || !Number.isFinite(entry) || !Number.isFinite(initial) || !Number.isFinite(reduce) || reduce <= 0) {
+    return prev; // Return previous TP if inputs are invalid
+  }
+  
+  // Calculate step value: percentage of the range from initial TP to Entry
+  // e.g., reduce = 5 → actualReducePercent = 0.5%
+  const actualReducePercent = reduce / 10; // 5 → 0.5%
+  const range = Math.abs(initial - entry);
+  const stepValue = range * (actualReducePercent / 100);
+  
   if (side === 'long') {
-    return ((c - e) / e) * 100;
-  } else {
-    return ((e - c) / e) * 100;
+    // LONG: TP moves DOWN (decreases) from initial TP towards entry
+    // newTP = prevTP - stepValue (but don't go below entry)
+    const newTP = prev - stepValue;
+    return Math.max(newTP, entry); // Don't go below entry
+  } else { // SHORT
+    // SHORT: TP moves UP (increases) from initial TP towards entry
+    // newTP = prevTP + stepValue (but don't go above entry)
+    const newTP = prev + stepValue;
+    return Math.min(newTP, entry); // Don't go above entry
   }
 }
 
 /**
- * Calculate PnL in USDT
- * @param {number} entryPrice - Entry price
- * @param {number} currentPrice - Current price
- * @param {number} amount - Position amount in USDT
- * @param {'long'|'short'} side - Position side
- * @returns {number} PnL in USDT
+ * Calculate next trailing stop loss price based on previous SL and reduce/up_reduce
+ * @deprecated This function is no longer used for trailing - SL should remain static after initial setup
+ * Only used for initial SL calculation
  */
-export function calculatePnL(entryPrice, currentPrice, amount, side) {
-  const pnlPercent = calculatePnLPercent(entryPrice, currentPrice, side);
-  return (Number(amount) * pnlPercent) / 100;
+export function calculateNextTrailingStop(prevSL, entryPrice, reducePercent, side, tpPrice = null) {
+  // This function is deprecated - SL should not be moved after initial setup
+  // Return previous SL to keep it static
+  return Number(prevSL);
 }
 
 /**
- * Calculate ignore threshold
- * @param {number} previousHigh - Previous candle high
- * @param {number} previousLow - Previous candle low
- * @param {number} ignore - Ignore percentage
- * @returns {number} Ignore threshold amount
+ * Calculate dynamic stop loss based on elapsed time (converging from TP)
+ * @deprecated This function is kept for backward compatibility but should not be used for trailing stops
  */
-export function calculateIgnoreThreshold(previousHigh, previousLow, ignore) {
-  const previousRange = Math.abs(Number(previousHigh) - Number(previousLow));
-  return (previousRange * Number(ignore)) / 100;
+export function calculateDynamicStopLoss(tpPrice, oc, reduce, upReduce, minutesElapsed, side, entryPrice = null) {
+  // Deprecated - not used anymore
+  return null;
 }
-
